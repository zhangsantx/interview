[{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/interview/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/interview/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. 提示 Use the power of React to create interactive blog posts. &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me! 信息 危险","keywords":""},{"title":"Welcome","type":0,"sectionRef":"#","url":"/interview/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":""},{"title":"intro","type":0,"sectionRef":"#","url":"/interview/docs-algo/intro","content":"intro Hello 算法","keywords":""},{"title":"Tutorial Intro","type":0,"sectionRef":"#","url":"/interview/docs/intro","content":"","keywords":""},{"title":"Getting Started​","type":1,"pageTitle":"Tutorial Intro","url":"/interview/docs/intro#getting-started","content":"Get started by creating a new site. Or try Docusaurus immediately with docusaurus.new. "},{"title":"What you'll need​","type":1,"pageTitle":"Tutorial Intro","url":"/interview/docs/intro#what-youll-need","content":"Node.js version 16.14 or above: When installing Node.js, you are recommended to check all checkboxes related to dependencies. "},{"title":"Generate a new site​","type":1,"pageTitle":"Tutorial Intro","url":"/interview/docs/intro#generate-a-new-site","content":"Generate a new Docusaurus site using the classic template. The classic template will automatically be added to your project after you run the command: npm init docusaurus@latest my-website classic  You can type this command into Command Prompt, Powershell, Terminal, or any other integrated terminal of your code editor. The command also installs all necessary dependencies you need to run Docusaurus. "},{"title":"Start your site​","type":1,"pageTitle":"Tutorial Intro","url":"/interview/docs/intro#start-your-site","content":"Run the development server: cd my-website npm run start  The cd command changes the directory you're working with. In order to work with your newly created Docusaurus site, you'll need to navigate the terminal there. The npm run start command builds your website locally and serves it through a development server, ready for you to view at http://localhost:3000/. Open docs/intro.md (this page) and edit some lines: the site reloads automatically and displays your changes. "},{"title":"aaa","type":0,"sectionRef":"#","url":"/interview/docs-algo/aaa","content":"aaa 111111111111111111111111111111111111","keywords":""},{"title":"aaa","type":0,"sectionRef":"#","url":"/interview/docs-computer/aaa","content":"aaa 111111111111111111111111111111111111","keywords":""},{"title":"intro","type":0,"sectionRef":"#","url":"/interview/docs-computer/intro","content":"intro Hello 计算机网络","keywords":""},{"title":"Vue和React脚手架配置代理","type":0,"sectionRef":"#","url":"/interview/docs/Vue和React脚手架配置代理","content":"","keywords":""},{"title":"一、vue 脚手架 rem 适配配置​","type":1,"pageTitle":"Vue和React脚手架配置代理","url":"/interview/docs/Vue和React脚手架配置代理#一vue-脚手架-rem-适配配置","content":"初始化脚手架 vue create my-app 安装依赖 npm i postcss-px2rem -D 根目录下建立 vue.config.js 文件，内容如下 var px2rem = require('postcss-px2rem') module.exports = { css: { loaderOptions: { postcss: { plugins: [px2rem({ remUnit: 375 / 10 })] // 375 设计稿宽度 } } } } src/utils/ 目录下创建 rem.js 或 adapter.js (响应式判断设备大小，设置不同的根字体大小)，内容如下 function adapter() { const dip = document.documentElement.clientWidth const rootFontSize = dip / 10 document.documentElement.style.fontSize = rootFontSize + 'px' } adapter() window.onresize = adapter 在 scr/index.js 入口文件中直接引入执行 rem.js 或 adapter.js import '@/utils/rem.js' // 或 import '@/utils/adapter.js' // @为src目录 最后，重新启动项目 npm run serve  "},{"title":"二、react 脚手架 rem 适配配置​","type":1,"pageTitle":"Vue和React脚手架配置代理","url":"/interview/docs/Vue和React脚手架配置代理#二react-脚手架-rem-适配配置","content":"初始化脚手架 create-react-app my-app 安装依赖 yarn add postcss-px2rem customize-cra react-app-rewired react-app-rewire-postcss 在根目录下创建 config.overrides.js ，内容如下 const { override } = require('customize-cra') const rewirePostcss = require('react-app-rewire-postcss') module.exports = override((config, env) =&gt; { rewirePostcss(config, { plugins: () =&gt; [ require('postcss-px2rem')({ // 375 设计稿宽度 remUnit: 375 / 10, exclude: /node-modules/i }) ] }) return config }) 更改 package.json 中的启动命令 &quot;scripts&quot;: { &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; } src/utils/ 目录下创建 rem.js 或 adapter.js (响应式判断设备大小，设置不同的根字体大小)，内容如下 function adapter() { const dip = document.documentElement.clientWidth const rootFontSize = dip / 10 document.documentElement.style.fontSize = rootFontSize + 'px' } adapter() window.onresize = adapter 在 scr/index.js 入口文件中直接引入执行 rem.js 或 adapter.js import './utils/rem.js' // 或 import './utils/adapter.js' 最后，重新启动项目 yarn start  注意：上述方法中的 rem.js 或 adapter.js 可以使用 lib-flexible 代替 1.安装flexible npm i amfe-flexible -D  2.在 index.js 入口文件中直接引入执行 import 'amfe-flexible'  "},{"title":"堆","type":0,"sectionRef":"#","url":"/interview/docs-data/堆","content":"","keywords":""},{"title":"堆的用途​","type":1,"pageTitle":"堆","url":"/interview/docs-data/堆#堆的用途","content":"当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。 有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 O(nlog(n))，查找最大值或者最小值时间复杂度都是 O(1)，但是，涉及到更新（插入或删除）数据时，时间复杂度为 O(n)，即使是使用复杂度为 O(log(n)) 的二分法找到要插入或者删除的数据，在移动数据时也需要 O(n) 的时间复杂度。 相对于有序数组而言，堆的主要优势在于更新数据效率较高。 堆的初始化时间复杂度为 O(nlog(n))，堆可以做到O(1)时间复杂度取出最大值或者最小值，O(log(n))时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。 "},{"title":"堆的分类​","type":1,"pageTitle":"堆","url":"/interview/docs-data/堆#堆的分类","content":"堆分为 最大堆 和 最小堆。二者的区别在于节点的排序方式。 最大堆 ：堆中的每一个节点的值都大于等于子树中所有节点的值最小堆 ：堆中的每一个节点的值都小于等于子树中所有节点的值 如下图所示，图1是最大堆，图2是最小堆  "},{"title":"堆的存储​","type":1,"pageTitle":"堆","url":"/interview/docs-data/堆#堆的存储","content":"之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 2*i，右子节点序号为 2*i+1）。 为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：  "},{"title":"堆的操作​","type":1,"pageTitle":"堆","url":"/interview/docs-data/堆#堆的操作","content":"堆的更新操作主要包括两种 : 插入元素 和 删除堆顶元素。操作过程需要着重掌握和理解。 在进入正题之前，再重申一遍，堆是一个公平的公司，有能力的人自然会走到与他能力所匹配的位置 "},{"title":"插入元素​","type":1,"pageTitle":"堆","url":"/interview/docs-data/堆#插入元素","content":"插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起 1.将要插入的元素放到最后  有能力的人会逐渐升职加薪，是金子总会发光的！！！ 2.从底向上，如果父结点比该元素小，则该节点和父结点交换，直到无法交换   "},{"title":"删除堆顶元素​","type":1,"pageTitle":"堆","url":"/interview/docs-data/堆#删除堆顶元素","content":"根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。 删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为&quot;堆化&quot;，堆化的方法分为两种： 一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。 自底向上堆化​ 在堆这个公司中，会出现老大离职的现象，老大离职之后，他的位置就空出来了 首先删除堆顶元素，使得数组中下标为1的位置空出。  那么他的位置由谁来接替呢，当然是他的直接下属了，谁能力强就让谁上呗 比较根结点的左子节点和右子节点，也就是下标为2,3的数组元素，将较大的元素填充到根结点(下标为1)的位置。  这个时候又空出一个位置了，老规矩，谁有能力谁上 一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部  这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。 自顶向下堆化​ 自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。  然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。   "},{"title":"堆的操作总结​","type":1,"pageTitle":"堆","url":"/interview/docs-data/堆#堆的操作总结","content":"插入元素 ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮删除堆顶元素 ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。 "},{"title":"堆排序​","type":1,"pageTitle":"堆","url":"/interview/docs-data/堆#堆排序","content":"堆排序的过程分为两步： 第一步是建堆，将一个无序的数组建立为一个堆第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。 "},{"title":"建堆​","type":1,"pageTitle":"堆","url":"/interview/docs-data/堆#建堆","content":"如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。 首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为n，那么我们需要对n/2到1的节点进行自顶向下（沉底）堆化。 具体过程如下图： 将初始的无序数组抽象为一棵树，图中的节点个数为6，所以4,5,6节点为叶节点，1,2,3节点为非叶节点，所以要对1-3号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从3号节点开始，一直到1号节点。 3号节点堆化结果：  2号节点堆化结果：  1号节点堆化结果：  至此，数组所对应的树已经成为了一个最大堆，建堆完成！ "},{"title":"排序​","type":1,"pageTitle":"堆","url":"/interview/docs-data/堆#排序","content":"由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。 现在思考两个问题： 删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？取出的堆顶元素存在哪，新建一个数组存？ 先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。 机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。 详细过程如下图所示： 取出第一个元素并堆化：  取出第二个元素并堆化：  取出第三个元素并堆化：  取出第四个元素并堆化：  取出第五个元素并堆化：  取出第六个元素并堆化：  堆排序完成！ "},{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/interview/blog/first-blog-post","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"认识数据结构","type":0,"sectionRef":"#","url":"/interview/docs-data/认识数据结构","content":"认识数据结构 数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。 数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构。 数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是分解与抽象。通过分解可以划分出数据的 3 个层次；再通过抽象，舍弃数据元素的具体内容，就得到逻辑结构。类似地，通过分解将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义。上述两个方面的结合可以将问题变换为数据结构。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到存储结构和实现运算，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程。","keywords":""},{"title":"字典（Map）","type":0,"sectionRef":"#","url":"/interview/docs-data/字典（Map）","content":"","keywords":""},{"title":"什么是集合​","type":1,"pageTitle":"字典（Map）","url":"/interview/docs-data/字典（Map）#什么是集合","content":"字典存储的是键值对，主要特点是一一对应。比如保存一个人的信息 数组形式：[19，&quot;Tom&quot;, 1.65]，可通过下标值取出信息。字典形式：{&quot;age&quot;: 19, &quot;name&quot;: &quot;Tom&quot;, &quot;height&quot;: 165}，可以通过 key 取出 value。 此外，在字典中 key 是不能重复且无序的，而 Value 可以重复。 "},{"title":"字典和映射的关系​","type":1,"pageTitle":"字典（Map）","url":"/interview/docs-data/字典（Map）#字典和映射的关系","content":"有些编程语言中称这种映射关系为字典，如 Swift 中的 Dictonary，Python 中的 dict。有些编程语言中称这种映射关系为 Map，比如 Java 中的 HashMap 和 TreeMap 等。 "},{"title":"字典的封装​","type":1,"pageTitle":"字典（Map）","url":"/interview/docs-data/字典（Map）#字典的封装","content":""},{"title":"字典的常见方法​","type":1,"pageTitle":"字典（Map）","url":"/interview/docs-data/字典（Map）#字典的常见方法","content":"set(key,value) 向字典中添加新元素。remove(key) 通过使用键值来从字典中移除键值对应的数据值。has(key) 如果某个键值存在于这个字典中，则返回 true，反之则返回 false。get(key) 通过键值查找特定的数值并返回。clear() 将这个字典中的所有元素全部删除。size() 返回字典所包含元素的数量。与数组的 length 属性类似。keys() 将字典所包含的所有键名以数组形式返回。values() 将字典所包含的所有数值以数组形式返回。 "},{"title":"代码实现​","type":1,"pageTitle":"字典（Map）","url":"/interview/docs-data/字典（Map）#代码实现","content":"// 字典结构的封装 export default class Map { constructor() { this.items = {}; } // has(key) 判断字典中是否存在某个 key has(key) { return this.items.hasOwnProperty(key); } // set(key, value) 在字典中添加键值对 set(key, value) { this.items[key] = value; } // remove(key) 在字典中删除指定的 key remove(key) { // 如果集合不存在该 key，返回 false if (!this.has(key)) return false; delete this.items[key]; } // get(key) 获取指定 key 的 value，如果没有，返回 undefined get(key) { return this.has(key) ? this.items[key] : undefined; } // 获取所有的 key keys() { return Object.keys(this.items); } // 获取所有的 value values() { return Object.values(this.items); } // size() 获取字典中的键值对个数 size() { return this.keys().length; } // clear() 清空字典中所有的键值对 clear() { this.items = {}; } } // 测试 const map = new Map(); // set() 测试 map.set(&quot;name&quot;, &quot;XPoet&quot;); map.set(&quot;age&quot;, 18); map.set(&quot;email&quot;, &quot;i@xpoet.cn&quot;); console.log(map); // {items: {name: &quot;XPoet&quot;, age: 18, email: &quot;i@xpoet.cn&quot;}} // has() 测试 console.log(map.has(&quot;name&quot;)); //--&gt; true console.log(map.has(&quot;address&quot;)); //--&gt; false // remove() 测试 map.remove(&quot;name&quot;); console.log(map); // {age: 18, email: &quot;i@xpoet.cn&quot;} // get() 测试 console.log(map.get(&quot;age&quot;)); //--&gt; 18 // keys() 测试 console.log(map.keys()); //--&gt; [&quot;age&quot;, &quot;email&quot;] // values() 测试 console.log(map.values()); //--&gt; [18, &quot;i@xpoet.cn&quot;] // size() 测试 console.log(map.size()); //--&gt; 2  "},{"title":"队列","type":0,"sectionRef":"#","url":"/interview/docs-data/队列","content":"","keywords":""},{"title":"什么是队列​","type":1,"pageTitle":"队列","url":"/interview/docs-data/队列#什么是队列","content":"队列（Queue）是一种运算受限的线性表，是 先进先出( FIFO，First In, First Out) 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 顺序队列 ，用链表实现的队列叫作 链式队列 ，只允许在表的 前端（front）进行删除操作被称之为 出队，只允许在表的 后端（rear）进行插入操作 称之为 入队。 队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。 特点：先进先出 (FIFO：First In First Out)。 生活中类似队列结构的场景： 排队，比如在电影院，商场，甚至是厕所排队。优先排队的人，优先处理。 (买票、结账、WC)。  队列的访问、插入和删除的时间复杂度分析： 假设队列中有n个元素。 访问：O（n）// 最坏情况 插入删除：O（1）// 后端插入前端删除元素  图解队列:   "},{"title":"程序中的队列​","type":1,"pageTitle":"队列","url":"/interview/docs-data/队列#程序中的队列","content":"打印队列：计算机打印多个文件的时候，需要排队打印。线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待 CPU 处理。 "},{"title":"队列的实现​","type":1,"pageTitle":"队列","url":"/interview/docs-data/队列#队列的实现","content":""},{"title":"队列的常用方法​","type":1,"pageTitle":"队列","url":"/interview/docs-data/队列#队列的常用方法","content":"enqueue(element) 向队列尾部添加一个（或多个）新的项。dequeue() 移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。front() 返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与 Map 类的 peek 方法非常类似）。isEmpty() 如果队列中不包含任何元素，返回 true，否则返回 false。size() 返回队列包含的元素个数，与数组的 length 属性类似。toString() 将队列中的内容，转成字符串形式。 "},{"title":"代码实现​","type":1,"pageTitle":"队列","url":"/interview/docs-data/队列#代码实现","content":"class Queue { constructor() { this.items = []; } // enqueue(item) 入队，将元素加入到队列中 enqueue(item) { this.items.push(item); } // dequeue() 出队，从队列中删除队头元素，返回删除的那个元素 dequeue() { return this.items.shift(); } // front() 查看队列的队头元素 front() { return this.items[0]; } // isEmpty() 查看队列是否为空 isEmpty() { return this.items.length === 0; } // size() 查看队列中元素的个数 size() { return this.items.length; } // toString() 将队列中的元素以字符串形式返回 toString() { let result = &quot;&quot;; for (let item of this.items) { result += item + &quot; &quot;; } return result; } } // 测试 const queue = new Queue(); // enqueue() 测试 queue.enqueue(&quot;a&quot;); queue.enqueue(&quot;b&quot;); queue.enqueue(&quot;c&quot;); queue.enqueue(&quot;d&quot;); console.log(queue.items); //--&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] // dequeue() 测试 queue.dequeue(); queue.dequeue(); console.log(queue.items); //--&gt; [&quot;c&quot;, &quot;d&quot;] // front() 测试 console.log(queue.front()); //--&gt; c // isEmpty() 测试 console.log(queue.isEmpty()); //--&gt; false // size() 测试 console.log(queue.size()); //--&gt; 2 // toString() 测试 console.log(queue.toString()); //--&gt; c d  "},{"title":"实际应用（击鼓传花）​","type":1,"pageTitle":"队列","url":"/interview/docs-data/队列#实际应用击鼓传花","content":"使用队列实现小游戏：击鼓传花。 分析：传入一组数据集合和设定的数字 number，循环遍历数组内元素，遍历到的元素为指定数字 number 时将该元素删除，直至数组剩下一个元素。 // 利用队列结构的特点实现击鼓传花游戏求解方法的封装 function passGame(nameList, number) { // 1、new 一个 Queue 对象 const queue = new Queue(); // 2、将 nameList 里面的每一个元素入队 for (const name of nameList) { queue.enqueue(name); } // 3、开始数数 // 队列中只剩下 1 个元素时就停止数数 while (queue.size() &gt; 1) { // 不是 number 时，重新加入到队尾 // 是 number 时，将其删除 for (let i = 0; i &lt; number - 1; i++) { // number 数字之前的人重新放入到队尾（即把队头删除的元素，重新加入到队列中） queue.enqueue(queue.dequeue()); } // number 对应这个人，直接从队列中删除 // 由于队列没有像数组一样的下标值不能直接取到某一元素， // 所以采用，把 number 前面的 number - 1 个元素先删除后添加到队列末尾， // 这样第 number 个元素就排到了队列的最前面，可以直接使用 dequeue 方法进行删除 queue.dequeue(); } // 4、获取最后剩下的那个人 const endName = queue.front(); // 5、返回这个人在原数组中对应的索引 return nameList.indexOf(endName); } // 测试 // passGame() 测试 const names = [&quot;lily&quot;, &quot;lucy&quot;, &quot;tom&quot;, &quot;tony&quot;, &quot;jack&quot;]; const targetIndex = passGame(names, 4); console.log(&quot;击鼓传花&quot;, names[targetIndex]); //--&gt; lily  "},{"title":"队列的分类​","type":1,"pageTitle":"队列","url":"/interview/docs-data/队列#队列的分类","content":""},{"title":"单队列​","type":1,"pageTitle":"队列","url":"/interview/docs-data/队列#单队列","content":"单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 顺序队列（数组实现） 和 链式队列（链表实现）。 顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。 假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 ”假溢出“ 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。 为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向对头元素，rear 指针指向队列最后一个元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》  "},{"title":"循环队列​","type":1,"pageTitle":"队列","url":"/interview/docs-data/队列#循环队列","content":"循环队列可以解决顺序队列的 假溢出 和 越界 问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。 还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。  顺序队列中，我们说 front==rear 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种： 可以设置一个标志变量 flag,当 front==rear 并且 flag=0 的时候队列为空，当 front==rear 并且 flag=1 的时候队列为满。队列为空的时候就是 front==rear ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是： (rear+1) % QueueSize= front 。  常见应用场景 当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。 阻塞队列： 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。线程池中的请求/任务队列： 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：FixedThreadPool 使用无界队列 LinkedBlockingQueue。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出java.util.concurrent.RejectedExecutionException 异常。Linux 内核进程队列（按优先级排队）现实生活中的派对，播放器上的播放列表;消息队列等等...... "},{"title":"优先队列​","type":1,"pageTitle":"队列","url":"/interview/docs-data/队列#优先队列","content":"生活中类似优先队列的场景： 优先排队的人，优先处理。 (买票、结账、WC)。排队中，有紧急情况（特殊情况）的人可优先处理。 优先级队列主要考虑的问题： 每个元素不再只是一个数据，还包含优先级。在添加元素过程中，根据优先级放入到正确位置。 代码实现​ // 优先队列内部的元素类 class QueueElement { constructor(element, priority) { this.element = element; this.priority = priority; } } // 优先队列类（继承 Queue 类） export class PriorityQueue extends Queue { constructor() { super(); } // enqueue(element, priority) 入队，将元素按优先级加入到队列中 // 重写 enqueue() enqueue(element, priority) { // 根据传入的元素，创建 QueueElement 对象 const queueElement = new QueueElement(element, priority); // 判断队列是否为空 if (this.isEmpty()) { // 如果为空，不用判断优先级，直接添加 this.items.push(queueElement); } else { // 定义一个变量记录是否成功添加了新元素 let added = false; for (let i = 0; i &lt; this.items.length; i++) { // 让新插入的元素进行优先级比较，priority 值越小，优先级越大 if (queueElement.priority &lt; this.items[i].priority) { // 在指定的位置插入元素 this.items.splice(i, 0, queueElement); added = true; break; } } // 如果遍历完所有元素，优先级都大于新插入的元素，就将新插入的元素插入到最后 if (!added) { this.items.push(queueElement); } } } // dequeue() 出队，从队列中删除前端元素，返回删除的元素 // 继承 Queue 类的 dequeue() dequeue() { return super.dequeue(); } // front() 查看队列的前端元素 // 继承 Queue 类的 front() front() { return super.front(); } // isEmpty() 查看队列是否为空 // 继承 Queue 类的 isEmpty() isEmpty() { return super.isEmpty(); } // size() 查看队列中元素的个数 // 继承 Queue 类的 size() size() { return super.size(); } // toString() 将队列中元素以字符串形式返回 // 重写 toString() toString() { let result = &quot;&quot;; for (let item of this.items) { result += item.element + &quot;-&quot; + item.priority + &quot; &quot;; } return result; } } // 测试 const priorityQueue = new PriorityQueue(); // 入队 enqueue() 测试 priorityQueue.enqueue(&quot;A&quot;, 10); priorityQueue.enqueue(&quot;B&quot;, 15); priorityQueue.enqueue(&quot;C&quot;, 11); priorityQueue.enqueue(&quot;D&quot;, 20); priorityQueue.enqueue(&quot;E&quot;, 18); console.log(priorityQueue.items); //--&gt; output: // QueueElement {element: &quot;A&quot;, priority: 10} // QueueElement {element: &quot;C&quot;, priority: 11} // QueueElement {element: &quot;B&quot;, priority: 15} // QueueElement {element: &quot;E&quot;, priority: 18} // QueueElement {element: &quot;D&quot;, priority: 20} // 出队 dequeue() 测试 priorityQueue.dequeue(); priorityQueue.dequeue(); console.log(priorityQueue.items); //--&gt; output: // QueueElement {element: &quot;B&quot;, priority: 15} // QueueElement {element: &quot;E&quot;, priority: 18} // QueueElement {element: &quot;D&quot;, priority: 20} // isEmpty() 测试 console.log(priorityQueue.isEmpty()); //--&gt; false // size() 测试 console.log(priorityQueue.size()); //--&gt; 3 // toString() 测试 console.log(priorityQueue.toString()); //--&gt; B-15 E-18 D-20  "},{"title":"数组、栈、和队列的比较图解​","type":1,"pageTitle":"队列","url":"/interview/docs-data/队列#数组栈和队列的比较图解","content":" "},{"title":"栈","type":0,"sectionRef":"#","url":"/interview/docs-data/栈","content":"","keywords":""},{"title":"什么是栈​","type":1,"pageTitle":"栈","url":"/interview/docs-data/栈#什么是栈","content":"栈 (stack)是一种运算受限的线性表，只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和删除数据（pop）。 特点：先进后出，后进先出 因而按照 后进先出（LIFO, Last In First Out） 的原理运作。在栈中，push 和 pop 的操作都发生在栈顶。 后进先出 是栈的一个重要的特点，表示就是后进入的元素，第一个弹出栈空间。类似于弹夹，后装入的子弹往往是最先被使用的。仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作 进栈、入栈或压栈 ，它是 把新元素放到栈顶元素的上面 ，使之成为新的栈顶元素；从一个栈删除元素又称作 出栈或退栈 ，它是把 栈顶元素删除掉 ，使其相邻的元素成为新的栈顶元素。 如下图所示：   栈的访问、插入和删除的时间复杂度分析 假设堆栈中有n个元素。 访问：O（n）// 最坏情况 插入删除：O（1）// 顶端插入和删除元素  "},{"title":"程序中的栈结构​","type":1,"pageTitle":"栈","url":"/interview/docs-data/栈#程序中的栈结构","content":"函数调用栈：A(B(C(D())))： 即 A 函数中调用 B，B 调用 C，C 调用 D；在 A 执行的过程中会将 A 压入栈，随后 B 执行时 B 也被压入栈，函数 C 和 D 执行时也会被压入栈。所以 当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶） ；函数 D 执行完之后，会弹出栈被释放，弹出栈的顺序为 D-&gt;C-&gt;B-&gt;A;递归： 为什么没有停止条件的递归会造成 栈溢出？比如函数 A 为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数 A 压入栈，最后造成栈溢出（Queue Overfloat）。 "},{"title":"栈的常见应用场景​","type":1,"pageTitle":"栈","url":"/interview/docs-data/栈#栈的常见应用场景","content":"当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 后进先出（LIFO, Last In First Out） 的特性时，我们就可以使用栈这个数据结构。 实现浏览器的回退和前进功能 我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:  "},{"title":"练习题​","type":1,"pageTitle":"栈","url":"/interview/docs-data/栈#练习题","content":"题目：有 6 个元素 6，5，4，3，2，1 按顺序进栈，问下列哪一个不是合法的出栈顺序？ A：5 4 3 6 1 2 （√）B：4 5 3 2 1 6 （√）C：3 4 6 5 2 1 （×）D：2 3 4 1 5 6 （√） 题目所说的按顺序进栈指的不是一次性全部进栈，而是有进有出，进栈顺序为 6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。 解析： A 答案：65 进栈，5 出栈，4 进栈出栈，3 进栈出栈，6 出栈，21 进栈，1 出栈，2 出栈（整体入栈顺序符合 654321）。B 答案：654 进栈，4 出栈，5 出栈，3 进栈出栈，2 进栈出栈，1 进栈出栈，6 出栈（整体的入栈顺序符合 654321）。C 答案：6543 进栈，3 出栈，4 出栈，之后应该 5 出栈而不是 6，所以错误。D 答案：65432 进栈，2 出栈，3 出栈，4 出栈，1 进栈出栈，5 出栈，6 出栈。符合入栈顺序。    "},{"title":"栈的实现​","type":1,"pageTitle":"栈","url":"/interview/docs-data/栈#栈的实现","content":"栈常用一维数组或链表来实现，用数组实现的栈叫作 顺序栈 ，用链表实现的栈叫作 链式栈 。 "},{"title":"栈的常用方法​","type":1,"pageTitle":"栈","url":"/interview/docs-data/栈#栈的常用方法","content":"push() 添加一个新元素到栈顶位置。pop() 移除栈顶的元素，同时返回被移除的元素。peek() 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。isEmpty() 如果栈里没有任何元素就返回 true，否则返回 false。size() 返回栈里的元素个数。这个方法和数组的 length 属性类似。toString() 将栈结构的内容以字符串的形式返回。 "},{"title":"代码实现​","type":1,"pageTitle":"栈","url":"/interview/docs-data/栈#代码实现","content":"// 栈结构的封装 class Map { constructor() { this.items = []; } // push(item) 压栈操作，往栈里面添加元素 push(item) { this.items.push(item); } // pop() 出栈操作，从栈中取出元素，并返回取出的那个元素 pop() { return this.items.pop(); } // peek() 查看栈顶元素 peek() { return this.items[this.items.length - 1]; } // isEmpty() 判断栈是否为空 isEmpty() { return this.items.length === 0; } // size() 获取栈中元素个数 size() { return this.items.length; } // toString() 返回以字符串形式的栈内元素数据 toString() { let result = &quot;&quot;; for (let item of this.items) { result += item + &quot; &quot;; } return result; } } // 测试 // push() 测试 stack.push(1); stack.push(2); stack.push(3); console.log(stack.items); //--&gt; [1, 2, 3] // pop() 测试 console.log(stack.pop()); //--&gt; 3 // peek() 测试 console.log(stack.peek()); //--&gt; 2 // isEmpty() 测试 console.log(stack.isEmpty()); //--&gt; false // size() 测试 console.log(stack.size()); //--&gt; 2 // toString() 测试 console.log(stack.toString()); //--&gt; 1 2  "},{"title":"实际应用（十进制转二进制）​","type":1,"pageTitle":"栈","url":"/interview/docs-data/栈#实际应用十进制转二进制","content":"利用栈结构的特点封装实现十进制转换为二进制的方法。 function dec2bin(dec) { // new 一个 Map，保存余数 const stack = new Map(); // 当不确定循环次数时，使用 while 循环 while (dec &gt; 0) { // 除二取余法 stack.push(dec % 2); // 获取余数，放入栈中 dec = Math.floor(dec / 2); // 除数除以二，向下取整 } let binaryString = &quot;&quot;; // 不断地从栈中取出元素（0 或 1），并拼接到一起。 while (!stack.isEmpty()) { binaryString += stack.pop(); } return binaryString; } // dec2bin() 测试 console.log(dec2bin(100)); //--&gt; 1100100 console.log(dec2bin(88)); //--&gt; 1011000  "},{"title":"aaa","type":0,"sectionRef":"#","url":"/interview/docs-interview/aaa","content":"","keywords":""},{"title":"title:'xxxxxx'​","type":1,"pageTitle":"aaa","url":"/interview/docs-interview/aaa#titlexxxxxx","content":"111111111111111111111111111111111111 "},{"title":"intro","type":0,"sectionRef":"#","url":"/interview/docs-interview/intro","content":"intro Hello 面经","keywords":""},{"title":"图","type":0,"sectionRef":"#","url":"/interview/docs-data/图","content":"","keywords":""},{"title":"什么是图​","type":1,"pageTitle":"图","url":"/interview/docs-data/图#什么是图","content":"在计算机程序设计中，图也是一种非常常见的数据结构，图论其实是一个非常大的话题，在数学上起源于哥尼斯堡七桥问题。 图是一种较为复杂的非线性结构。 为啥说其较为复杂呢？ 根据前面的内容，我们知道： 线性数据结构的元素满足唯一的线性关系，每个元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继。树形数据结构的元素之间有着明显的层次关系。 但是，图形结构的元素之间的关系是任意的。 何为图呢？ 简单来说，图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：G(V,E)，其中，G表示一个图，V表示顶点的集合，E表示边的集合。 下图所展示的就是图这种数据结构，并且还是一张有向图。  图在我们日常生活中的例子很多！比如我们在社交软件上好友关系就可以用图来表示。 图是一种与树有些相似的数据结构。 实际上，在数学的概念上，树是图的一种。我们知道树可以用来模拟很多现实的数据结构，比如：家谱/公司组织架构等等。 图通常有什么特点呢？ 一组顶点：通常用 V (Vertex) 表示顶点的集合一组边：通常用 E (Edge) 表示边的集合边是顶点和顶点之间的连线边可以是有向的，也可以是无向的。（比如 A — B，通常表示无向。 A –&gt; B，通常表示有向） "},{"title":"图的常用术语​","type":1,"pageTitle":"图","url":"/interview/docs-data/图#图的常用术语","content":"我们在学习树的时候，树有很多的其他术语，了解这些术语有助于我们更深层次的理解图。但是图的术语其实非常多，如果你找一本专门讲图的各个方面的书籍，会发现只是术语就可以占据一个章节。这里，这里介绍几个比较常见的术语，某些术语后面用到的时候，再了解，没有用到的，不做赘述。下面这是个抽象出来的图顶点 顶点刚才我们已经介绍过了，表示图中的一个结点。比如地铁站中某个站/多个村庄中的某个村庄/互联网中的某台主机/人际关系中的人。 边 边表示顶点和顶点之间的连线。比如地铁站中两个站点之间的直接连线, 就是一个边。注意：这里的边不要叫做路径，路径有其他的概念，后面会区分。 相邻顶点 由一条边连接在一起的顶点称为相邻顶点。比如 0 - 1 是相邻的，0 - 3 是相邻的。0 - 2 是不相邻的。 度 一个顶点的度是相邻顶点的数量比如 0 顶点和其他两个顶点相连，0 顶点的度是 2比如 1 顶点和其他四个顶点相连，1 顶点的度是 4 路径 路径是顶点 v1，v2…，vn 的一个连续序列, 比如上图中 0 1 5 9 就是一条路径。简单路径: 简单路径要求不包含重复的顶点. 比如 0 1 5 9 是一条简单路径。回路：第一个顶点和最后一个顶点相同的路径称为回路。比如 0 1 5 6 3 0。 无向图 上面的图就是一张无向图，因为所有的边都没有方向。比如 0 - 1 之间有变，那么说明这条边可以保证 0 -&gt; 1，也可以保证 1 -&gt; 0。 有向图 有向图表示的图中的边是有方向的。比如 0 -&gt; 1，不能保证一定可以 1 -&gt; 0，要根据方向来定。 出度 指向别人的数量（从该顶点出去的边的条数） 入度 指向自己的数量（表示进入该顶点的边的条数） "},{"title":"无权图和带权图​","type":1,"pageTitle":"图","url":"/interview/docs-data/图#无权图和带权图","content":"无权图 我们上面的图就是一张无权图（边没有携带权重）我们上面的图中的边是没有任何意义的，不能收 0 - 1 的边，比 4 - 9 的边更远或者用的时间更长。 带权图 带权图表示边有一定的权重这里的权重可以是任意你希望表示的数据：比如距离或者花费的时间或者票价。我们来看一张有向和带权的图 "},{"title":"显示生活中的图​","type":1,"pageTitle":"图","url":"/interview/docs-data/图#显示生活中的图","content":"对交通流量建模 顶点可以表示街道的十字路口，边可以表示街道.。加权的边可以表示限速或者车道的数量或者街道的距离。建模人员可以用这个系统来判定最佳路线以及最可能堵车的街道。 对飞机航线建模 航空公司可以用图来为其飞行系统建模。将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。加权的边可以表示从一个机场到另一个机场的航班成本，或两个机场间的距离。建模人员可以利用这个系统有效的判断从一个城市到另一个城市的最小航行成本。 "},{"title":"图的存储方式​","type":1,"pageTitle":"图","url":"/interview/docs-data/图#图的存储方式","content":""},{"title":"邻接矩阵存储​","type":1,"pageTitle":"图","url":"/interview/docs-data/图#邻接矩阵存储","content":"邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。 如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 A[i][j]=n 。 在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，A[i][j]=1，当顶点i和顶点j没有关系时，A[i][j]=0。如下图所示：  值得注意的是：无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。  邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间， "},{"title":"邻接表存储​","type":1,"pageTitle":"图","url":"/interview/docs-data/图#邻接表存储","content":"针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—邻接表 。 邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 邻接表。如下图所示：   大家可以数一数邻接表中所存储的元素的个数以及图中边的条数，你会发现： 在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。图片解析 在二维数组中，0 表示没有连线，1 表示有连线。通过二维数组，我们可以很快的找到一个顶点和哪些顶点有连线。（比如 A 顶点, 只需要 遍历第一行即可）另外，A - A，B - B（也就是顶点到自己的连线），通常使用 0 表示。 邻接矩阵的问题 如果是一个无向图，邻接矩阵展示出来的二维数组，其实是一个对称图。 也就是 A -&gt; D 是 1 的时候，对称的位置 D -&gt; 1 一定也是 1。那么这种情况下会造成空间的浪费，解决办法需自己去研究下。 邻接矩阵还有一个比较严重的问题就是如果图是一个稀疏图 那么矩阵中将存在大量的 0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。而且即使只有一个边，我们也必须遍历一行来找出这个边，也浪费很多时间。 "},{"title":"图的遍历​","type":1,"pageTitle":"图","url":"/interview/docs-data/图#图的遍历","content":""},{"title":"广度优先遍历（BFS）​","type":1,"pageTitle":"图","url":"/interview/docs-data/图#广度优先遍历bfs","content":"1.任意选择一个顶点 2.找到走1步就可以到达的顶点，分别遍历他们（顺序随意，但是需要在一起） 3.找到走2步就可以到达的顶点...... ...... 4.以此类推，遍历完所有顶点  广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：  广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列 。具体过程如下图所示： 第1步：  第2步：  第3步：  第4步：  第5步：  第6步：  "},{"title":"深度优先遍历（DFS）​","type":1,"pageTitle":"图","url":"/interview/docs-data/图#深度优先遍历dfs","content":"1.任意选择一个顶点 2.随机找到走1步就可以到达的顶点并遍历他，如果都遍历访问过，则返回到存在步数为1可到达的没有被访问遍历的节点处 ...... 4.以此类推，遍历完所有顶点（顶点不可以重复遍历）  深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示： 和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈 。具体过程如下图所示： 第1步：  和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈 。具体过程如下图所示： 第1步：  第2步：  第3步：  第4步：  第5步：  第6步：  "},{"title":"练习题​","type":1,"pageTitle":"图","url":"/interview/docs-data/图#练习题","content":"  选项A 广度优先 以h为顶点，步数为1可访问的顶点为c、a h-c-a 步数为2可访问的顶点为b、d、e h-c-a-b-d-e 步数为3可访问的顶点为g、f h-c-a-b-d-e-g-f  选项B 广度优先 以h为顶点，步数为1可访问的顶点为a、f、g e-a-f-g 步数为2可访问的顶点为b、h e-a-f-g-b-h 步数为3可访问的顶点为c、d e-a-f-g-b-h-c-d  选项C 广度优先 以d为顶点，步数为1可访问的顶点为b、c d-b-c 步数为2可访问的顶点为a、h d-b-c-a-h 步数为3可访问的顶点为e d-b-c-a-h-e 步数为3可访问的顶点为f、g d-b-c-a-h-e-f-g  选项D 深度优先 以a为顶点，步数为1可访问的顶点为b、h、e，选择b a-b 以b为顶点，步数为1可访问的顶点为c、d，选择c a-b-c 以c为顶点，步数为1可访问的顶点为d、h，选择d a-b-c-d 以d为顶点，步数为1可访问的顶点为b（已遍历）、c（已遍历），返回上一个遍历访问的节点c（c存在步数为1且没被遍历访问过的结点） a-b-c-d 以c为顶点，步数为1可访问的顶点为b（已遍历）、h，选择h a-b-c-d-h 以h为顶点，步数为1可访问的顶点为c（已遍历）、a（已遍历），返回到节点a a-b-c-d-h 以a为顶点，步数为1可访问的顶点为e，选择e a-b-c-d-h-e 以e为顶点，步数为1可访问的顶点为f、g，选择f a-b-c-d-h-e-f 以f为顶点，步数为1可访问的顶点为g，选择g a-b-c-d-h-e-f-g   ① 找出关键路径，关键路径的权值和即为施工的最短时间，修改则可以延长或缩短工期（注意找路径的时候每个顶点只能使用一次） 关键路径：从起始顶点（入度为0，仅一个），到结束顶点（出度为0，仅一个）组成的所有路径中权值和最大的路径即为关键路径，关键路径可能不止一条 ② 多条关键路径需要修改可以使得每条关键路径都会受到影响的才有效 ③ 注意：当修改之后，原来的关键路径可能会变成非关键路径   选项A 修改ce，此操作只会影响蓝色和紫色的关键路径，红色不受影响（此时路径权值和最大的仍是红色，即红色为关键路径，也就是最短工期），所以不会达到效果 选项B 修改de，此操作只会影响蓝色和紫色的关键路径，红色不受影响，所以不会达到效果 选项C 修改fd，此操作只会三条关键路径都会受到影响，会达到效果 选项B 修改fh，此操作只会影响红色和紫色的关键路径，蓝色不受影响，所以不会达到效果 "},{"title":"哈希表","type":0,"sectionRef":"#","url":"/interview/docs-data/哈希表","content":"","keywords":""},{"title":"什么是哈希表​","type":1,"pageTitle":"哈希表","url":"/interview/docs-data/哈希表#什么是哈希表","content":"哈希表是一种非常重要的数据结构，几乎所有的编程语言都直接或者间接应用这种数据结构。 哈希表通常是基于数组实现的，但是相对于数组，它存在更多优势： 哈希表可以提供非常快速的 插入-删除-查找 操作。无论多少数据，插入和删除值都只需接近常量的时间，即 O(1) 的时间复杂度。实际上，只需要几个机器指令即可完成。哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。哈希表相对于树来说编码要简单得多。 哈希表同样存在不足之处： 哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素。通常情况下，哈希表中的 key 是不允许重复的，不能放置相同的 key，用于保存不同的元素。 哈希表是什么？ 哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。哈希表的结构就是数组，但它神奇之处在于对下标值的一种变换，这种变换我们可以称之为哈希函数，通过哈希函数可以获取 HashCode。 通过以下案例了解哈希表： 案例一：公司想要存储 1000 个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把某一员工的姓名转换为它对应的工号，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。案例二：存储联系人和对应的电话号码：当要查找张三（比如）的号码时，若使用数组：由于不知道存储张三数据对象的下标值，所以查找起来十分麻烦，使用链表时也同样麻烦。而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值，再通过下标值查找效率就非常高了。 也就是说：哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的下标值，建立字符串和下标值的映射关系。 "},{"title":"什么是哈希化​","type":1,"pageTitle":"哈希表","url":"/interview/docs-data/哈希表#什么是哈希化","content":"为了把字符串转化为对应的下标值，需要有一套编码系统，为了方便理解我们创建这样一套编码系统：比如 a 为 1，b 为 2，c 为 3，以此类推 z 为 26，空格为 27（不考虑大写情况）。 有了编码系统后，将字母转化为数字也有很多种方案： 方案一：数字相加。 例如 cats 转化为数字：3 + 1 + 20 + 19 = 43，那么就把 43 作为 cats 单词的下标值储存在数组中； 但是这种方式会存在这样的问题：很多的单词按照该方式转化为数字后都是 43，比如 was。而在数组中一个下标值只能储存一个数据，所以该方式不合理。 方案二：幂的连乘。 我们平时使用的大于 10 的数字，就是用幂的连乘来表示它的唯一性的。比如： 6543 = 6 * 10^3 + 5 * 10^2 + 4 * 10 + 3；这样单词也可以用该种方式来表示：cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60337。 虽然该方式可以保证字符的唯一性，但是如果是较长的字符（如 aaaaaaaaaa）所表示的数字就非常大，此时要求很大容量的数组，然而其中却有许多下标值指向的是无效的数据（比如不存在 zxcvvv 这样的单词），造成了数组空间的浪费。 两种方案总结： 第一种方案（让数字相加求和）产生的数组下标太少。第二种方案（与 27 的幂相乘求和）产生的数组下标又太多。 现在需要一种压缩方法，把幂的连乘方案系统中得到的巨大整数范围压缩到可接受的数组范围中。可以通过取余操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。 "},{"title":"哈希表的常见概念​","type":1,"pageTitle":"哈希表","url":"/interview/docs-data/哈希表#哈希表的常见概念","content":"哈希化 将大数字转化成数组范围内下标的过程，称之为哈希化。 哈希函数 我们通常会将单词转化成大数字，把大数字进行哈希化的代码实现放在一个函数中，该函数就称为哈希函数。 哈希表 对最终数据插入的数组进行整个结构的封装，得到的就是哈希表。 "},{"title":"地址冲突及其解决方法​","type":1,"pageTitle":"哈希表","url":"/interview/docs-data/哈希表#地址冲突及其解决方法","content":"在实际中，经过哈希函数哈希化过后得到的下标值可能有重复，这种情况称为冲突，冲突是不可避免的，我们只能解决冲突。 解决冲突常见的两种方案：链地址法（拉链法）和开放地址法。 "},{"title":"链地址法（拉链法）​","type":1,"pageTitle":"哈希表","url":"/interview/docs-data/哈希表#链地址法拉链法","content":"如下图所示，我们将每一个数字都对 10 进行取余操作，则余数的范围 0~9 作为数组的下标值（哈希化）。并且，数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的数组或链表。  这样可以根据下标值获取到整个数组或链表，之后继续在数组或链表中查找就可以了。而且，产生冲突的元素一般不会太多。 总结：链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据，而是一条链条，这条链条常使用的数据结构为数组或链表，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。 "},{"title":"开放地址法​","type":1,"pageTitle":"哈希表","url":"/interview/docs-data/哈希表#开放地址法","content":"开放地址法的主要工作方式是，哈希化之后，寻找空白的单元格来放置冲突的数据项。  根据探测空白单元格位置方式的不同，可分为三种方法： 线性探测二次探测再哈希法 线性探测​ 当插入 13 时： 经过哈希化（对 10 取余）之后得到的下标值 index=3，但是该位置已经放置了数据 33。而线性探测就是从 index 位置+1 开始向后一个一个来查找合适的位置来放置 13，所谓合适的位置指的是空的位置，如上图中 index=4 的位置就是合适的位置。 当查询 13 时： 首先 13 经过哈希化得到 index=3，如果 index=3 的位置存放的数据与需要查询的数据 13 相同，就直接返回； 不相同时，则线性查找，从 index+1 位置开始一个一个位置地查找数据 13。查询过程中不会遍历整个哈希表，只要查询到空位置，就停止，因为插入 13 时不会跳过空位置去插入其他位置。 当删除 13 时： 删除操作和上述两种情况类似，但需要注意的是，删除一个数据项时，不能将该位置下标的内容设置为 null，否则会影响到之后其他的查询操作，因为一遇到为 null 的位置就会停止查找。通常删除一个位置的数据项时，我们可以将它进行特殊处理（比如设置为-1），这样在查找时遇到-1 就知道要继续查找。 线性探测存在的问题： 线性探测存在一个比较严重的问题，就是聚集。如哈希表中还没插入任何元素时，插入 23、24、25、26、27，这就意味着下标值为 3、4、5、6、7 的位置都放置了数据，这种一连串填充单元就称为聚集。聚集会影响哈希表的性能，无论是插入/查询/删除都会影响。比如插入 13 时就会发现，连续的单元 3~7 都不允许插入数据，并且在插入的过程中需要经历多次这种情况。二次探测法可以解决该问题。  二次探测​ 上文所说的线性探测存在的问题： 如果之前的数据是连续插入的，那么新插入的一个数据可能需要探测很长的距离； 二次探测是在线性探测的基础上进行了优化： 线性探测：我们可以看成是步长为 1 的探测，比如从下表值 x 开始，那么线性探测就是按照下标值：x+1、x+2、x+3 等依次探测； 二次探测：对步长进行了优化，比如从下标值 x 开始探测：x+1^2^、x+2^2^、x+3^3^ 。这样一次性探测比较长的距离，避免了数据聚集带来的影响。 二次探测存在的问题： 当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成步长不一的一种聚集（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。 再哈希法​ 在开放地址法中寻找空白单元格的最好的解决方式为再哈希化。 二次探测的步长是固定的：1，4，9，16 依次类推。现在需要一种方法：产生一种依赖关键字(数据)的探测序列，而不是每个关键字探测步长都一样。这样，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列。再哈希法的做法为：把关键字用另一个哈希函数，再做一次哈希化，用这次哈希化的结果作为该关键字的步长。 第二次哈希化需要满足以下两点： 和第一个哈希函数不同，不然哈希化后的结果仍是原来位置；不能输出为 0，否则每次探测都是原地踏步的死循环； 优秀的哈希函数： stepSize = constant - （key % constant）；其中 constant 是质数，且小于数组的容量；例如：stepSize = 5 - （key % 5），满足需求，并且结果不可能为 0； 哈希化的效率 哈希表中执行插入和搜索操作效率是非常高的。 如果没有发生冲突，那么效率就会更高；如果发生冲突，存取时间就依赖后来的探测长度；平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度会越来越长。 装填因子​ 装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值；装填因子 = 总数据项 / 哈希表长度；开放地址法的装填因子最大为 1，因为只有空白的单元才能放入元素；链地址法的装填因子可以大于 1，因为只要愿意，拉链法可以无限延伸下去； 不同探测方式性能的比较​ 线性探测 可以看到，随着装填因子的增大，平均探测长度呈指数形式增长，性能较差。实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，而速度上升。 二次探测和再哈希化的性能 二次探测和再哈希法性能相当，它们的性能比线性探测略好。由下图可知，随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。 链地址法的性能 可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如 Java 中的 HashMap 中使用的就是链地址法。 "},{"title":"哈希函数​","type":1,"pageTitle":"哈希表","url":"/interview/docs-data/哈希表#哈希函数","content":"哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法。提高速度的一个方法是在哈希函数中尽量减少乘法和除法。 性能高的哈希函数应具备以下两个优点： 快速的计算；均匀的分布； "},{"title":"快速计算​","type":1,"pageTitle":"哈希表","url":"/interview/docs-data/哈希表#快速计算","content":"霍纳法则：在中国霍纳法则也叫做秦久韶算法，具体算法为：  求多项式的值时，首先计算最内层括号内一次多项式的值，然后由内向外逐层计算一次多项式的值。这种算法把求 n 次多项式 f(x)的值就转化为求 n 个一次多项式的值。 变换之前： 乘法次数：n(n+1)/2 次；加法次数：n 次； 变换之后： 乘法次数：n 次；加法次数：n 次； 如果使用大 O 表示时间复杂度的话，直接从变换前的 O(N^2)降到了 O(N)。 "},{"title":"均匀分布​","type":1,"pageTitle":"哈希表","url":"/interview/docs-data/哈希表#均匀分布","content":"在设计哈希表时，我们已经有办法处理映射到相同下标值的情况：链地址法或者开放地址法。但是，为了提供效率，最好的情况还是让数据在哈希表中均匀分布。因此，我们需要在使用常量的地方，尽量使用质数。比如：哈希表的长度、N 次幂的底数等。 Java 中的 HashMap 采用的是链地址法，哈希化采用的是公式为：index = HashCode(key) &amp; (Length-1) 即将数据化为二进制进行与运算，而不是取余运算。这样计算机直接运算二进制数据，效率更高。但是 JavaScript 在进行较大数据的与运算时会出现问题，所以我们使用 JavaScript 实现哈希化时采用取余运算。 "},{"title":"哈希表的常用方法​","type":1,"pageTitle":"哈希表","url":"/interview/docs-data/哈希表#哈希表的常用方法","content":"put(key, value) 插入或修改操作。get(key) 获取哈希表中特定位置的元素。remove(key) 删除哈希表中特定位置的元素。isEmpty() 如果哈希表中不包含任何元素，返回 trun，如果哈希表长度大于 0 则返回 false。size() 返回哈希表包含的元素个数。resize(value) 对哈希表进行扩容操作。 "},{"title":"哈希函数的实现​","type":1,"pageTitle":"哈希表","url":"/interview/docs-data/哈希表#哈希函数的实现","content":"首先使用霍纳法则计算 hashCode 的值，通过取余操作实现哈希化，此处先简单地指定数组的大小。 hashFn(string, limit = 7) { // 自己采用的一个质数（无强制要求，质数即可） const PRIME = 31; // 1、定义存储 hashCode 的变量 let hashCode = 0; // 2、使用霍纳法则（秦九韶算法），计算 hashCode 的值 for (let item of string) { hashCode = PRIME * hashCode + item.charCodeAt(); } // 3、对 hashCode 取余，并返回 return hashCode % limit; }  "},{"title":"哈希表的实现​","type":1,"pageTitle":"哈希表","url":"/interview/docs-data/哈希表#哈希表的实现","content":"创建哈希表类​ 封装的哈希表的数据结构模型  首先创建哈希表类 HashTable，并添加必要的属性和上面实现的哈希函数，再进行其他方法的实现。 class HashTable { constructor() { this.storage = []; // 哈希表存储数据的变量 this.count = 0; // 当前存放的元素个数 this.limit = 7; // 哈希表长度（初始设为质数 7） } }  实现put()方法​ 哈希表的插入和修改操作是同一个函数：因为，当使用者传入一个 [key, value] 时，如果原来不存在该 key，那么就是插入操作，如果原来已经存在该 key，那么就是修改操作。  实现思路： 首先，根据 key 获取索引值 index，目的为将数据插入到 storage 的对应位置；然后，根据索引值取出 bucket，如果 bucket 不存在，先创建 bucket，随后放置在该索引值的位置；接着，判断新增还是修改原来的值。如果已经有值了，就修改该值；如果没有，就执行后续操作。最后，进行新增数据操作。 // put(key, value) 往哈希表里添加数据 put(key, value) { // 1、根据 key 获取要映射到 storage 里面的 index（通过哈希函数获取） const index = hashFn(key, this.limit); // 2、根据 index 取出对应的 bucket let bucket = this.storage[index]; // 3、判断是否存在 bucket if (bucket === undefined) { bucket = []; // 不存在则创建 this.storage[index] = bucket; } // 4、判断是插入数据操作还是修改数据操作 for (let i = 0; i &lt; bucket.length; i++) { let tuple = bucket[i]; // tuple 的格式：[key, value] if (tuple[0] === key) { // 如果 key 相等，则修改数据 tuple[1] = value; return; // 修改完 tuple 里数据，return 终止不再往下执行。 } } // 5、bucket 新增数据 bucket.push([key, value]); // bucket 存储元组 tuple，格式为 [key, value] this.count++; // 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容 if (this.count / this.limit &gt; this.loadFactor) { this.resize(this.getPrime(this.limit * 2)); } }  实现get()方法​ 实现思路： 首先，根据 key 通过哈希函数获取它在 storage 中对应的索引值 index。然后，根据索引值获取对应的 bucket。接着，判断获取到的 bucket 是否为 null，如果为 null，直接返回 null。随后，线性遍历 bucket 中每一个 key 是否等于传入的 key。如果等于，直接返回对应的 value。最后，遍历完 bucket 后，仍然没有找到对应的 key，直接 return null 即可。 // 根据 get(key) 获取 value get(key) { const index = hashFn(key, this.limit); const bucket = this.storage[index]; if (bucket === undefined) { return null; } for (const tuple of bucket) { if (tuple[0] === key) { return tuple[1]; } } return null; }  实现remove()方法​ 实现思路： 首先，根据 key 通过哈希函数获取它在 storage 中对应的索引值 index。然后，根据索引值获取对应的 bucket。接着，判断获取到的 bucket 是否为 null，如果为 null，直接返回 null。随后，线性查找 bucket，寻找对应的数据，并且删除。最后，依然没有找到，返回 null。 // remove(key) 删除指定 key 的数据 remove(key) { const index = hashFn(key, this.limit); const bucket = this.storage[index]; if (bucket === undefined) { return null; } // 遍历 bucket，找到对应位置的 tuple，将其删除 for (let i = 0, len = bucket.length; i &lt; len; i++) { const tuple = bucket[i]; if (tuple[0] === key) { bucket.splice(i, 1); // 删除对应位置的数组项 this.count--; // 根据装填因子的大小，判断是否要进行哈希表压缩 if (this.limit &gt; 7 &amp;&amp; this.count / this.limit &lt; this.minLoadFactor) { this.resize(this.getPrime(Math.floor(this.limit / 2))); } return tuple; } } }  实现isEmpty()方法​ isEmpty() { return this.count === 0; }  实现size()方法​ size() { return this.count; }  哈希表的扩容与压缩​ 为什么需要扩容？ 前面我们在哈希表中使用的是长度为 7 的数组，由于使用的是链地址法，装填因子(loadFactor)可以大于 1，所以这个哈希表可以无限制地插入新数据。但是，随着数据量的增多，storage 中每一个 index 对应的 bucket 数组（链表）就会越来越长，这就会造成哈希表效率的降低。 什么情况下需要扩容？ 常见的情况是 loadFactor &gt; 0.75 的时候进行扩容。 如何进行扩容？ 简单的扩容可以直接扩大两倍（关于质数，之后讨论）。扩容之后所有的数据项都要进行同步修改。 实现思路： 首先，定义一个变量，比如 oldStorage 指向原来的 storage。然后，创建一个新的容量更大的数组，让 this.storage 指向它。最后，将 oldStorage 中的每一个 bucket 中的每一个数据取出来依次添加到 this.storage 指向的新数组中。  实现resize()方法​ 装填因子 = 哈希表中数据 / 哈希表长度，即 loadFactor = count / HashTable.length。 resize 方法，既可以实现哈希表的扩容，也可以实现哈希表容量的压缩。 // 重新调整哈希表大小，扩容或压缩 resize(newLimit) { // 1、保存旧的 storage 数组内容 const oldStorage = this.storage; // 2、重置所有属性 this.storage = []; this.count = 0; this.limit = newLimit; // 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage for (const bucket of oldStorage) { if (bucket) { for (const b of bucket) { this.put(b[0], b[1]); } } } }  通常情况下当装填因子 laodFactor &gt; 0.75 时，对哈希表进行扩容。在哈希表中的添加方法（push 方法）中添加如下代码，判断是否需要调用扩容函数进行扩容。 // 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容 if (this.count / this.limit &gt; this.loadFactor) { this.resize(this.getPrime(this.limit * 2)); }  当装填因子 laodFactor &lt; 0.25 时，对哈希表容量进行压缩。在哈希表中的删除方法（remove 方法）中添加如下代码，判断是否需要调用扩容函数进行压缩。 // 根据装填因子的大小，判断是否要进行哈希表压缩 if (this.limit &gt; 7 &amp;&amp; this.count / this.limit &lt; this.minLoadFactor) { this.resize(this.getPrime(Math.floor(this.limit / 2))); }  选择质数作为哈希表容量​ 质数判断​ 1 不是质数 方法一：针对质数的特点：只能被 1 和 number 整除，不能被 2 ~ (number-1)整除。遍历 2 ~ (num-1) 。 这种方法虽然能实现质数的判断，但是效率不高。  function isPrime(number) { if (number &lt;= 1) return false; for (let i = 2; i &lt; number; i++) { if (number % i === 0) { return false; } } return true; }  方法二：只需要遍历 2 ~ num 的平方根即可。该方法性能较好。  function isPrime(number) { if (number &lt;= 1 || number === 4) return false; const temp = Math.ceil(Math.sqrt(number)); for (let i = 2; i &lt; temp; i++) { if (number % i === 0) { return false; } } return true; }  实现扩容或压缩后的哈希表容量为质数​ 实现思路： 2 倍扩容或压缩之后，通过循环调用 isPrime 判断得到的容量是否为质数，不是则+1，直到是为止。比如原长度：7，2 倍扩容后长度为 14，14 不是质数，14 + 1 = 15 不是质数，15 + 1 = 16 不是质数，16 + 1 = 17 是质数，停止循环，由此得到质数 17。 第一步：首先需要为 HashTable 类添加判断质数的 isPrime 方法和获取质数的 getPrime 方法：  // getPrime(number) 根据传入的 number 获取最临近的质数 getPrime(number) { while (!isPrime(number)) { number++; } return number; }  修改添加元素的 put 方法和删除元素的 remove 方法中关于数组扩容的相关操作： 在 put 方法中添加如下代码：  // 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容 if (this.count / this.limit &gt; this.loadFactor) { this.resize(this.getPrime(this.limit * 2)); }  在 remove 方法中添加如下代码：  // 根据装填因子的大小，判断是否要进行哈希表压缩 if (this.limit &gt; 7 &amp;&amp; this.count / this.limit &lt; this.minLoadFactor) { this.resize(this.getPrime(Math.floor(this.limit / 2))); }  哈希表完整实现​ class HashTable { constructor() { this.storage = []; // 哈希表存储数据的变量 this.count = 0; // 当前存放的元素个数 this.limit = 7; // 哈希表长度（初始设为质数 7） // 装填因子(已有个数/总个数) this.loadFactor = 0.75; this.minLoadFactor = 0.25; } // getPrime(number) 根据传入的 number 获取最临近的质数 getPrime(number) { while (!isPrime(number)) { number++; } return number; } // put(key, value) 往哈希表里添加数据 put(key, value) { // 1、根据 key 获取要映射到 storage 里面的 index（通过哈希函数获取） const index = hashFn(key, this.limit); // 2、根据 index 取出对应的 bucket let bucket = this.storage[index]; // 3、判断是否存在 bucket if (bucket === undefined) { bucket = []; // 不存在则创建 this.storage[index] = bucket; } // 4、判断是插入数据操作还是修改数据操作 for (let i = 0; i &lt; bucket.length; i++) { let tuple = bucket[i]; // tuple 的格式：[key, value] if (tuple[0] === key) { // 如果 key 相等，则修改数据 tuple[1] = value; return; // 修改完 tuple 里数据，return 终止，不再往下执行。 } } // 5、bucket 新增数据 bucket.push([key, value]); // bucket 存储元组 tuple，格式为 [key, value] this.count++; // 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容 if (this.count / this.limit &gt; this.loadFactor) { this.resize(this.getPrime(this.limit * 2)); } } // 根据 get(key) 获取 value get(key) { const index = hashFn(key, this.limit); const bucket = this.storage[index]; if (bucket === undefined) { return null; } for (const tuple of bucket) { if (tuple[0] === key) { return tuple[1]; } } return null; } // remove(key) 删除指定 key 的数据 remove(key) { const index = hashFn(key, this.limit); const bucket = this.storage[index]; if (bucket === undefined) { return null; } // 遍历 bucket，找到对应位置的 tuple，将其删除 for (let i = 0, len = bucket.length; i &lt; len; i++) { const tuple = bucket[i]; if (tuple[0] === key) { bucket.splice(i, 1); // 删除对应位置的数组项 this.count--; // 根据装填因子的大小，判断是否要进行哈希表压缩 if (this.limit &gt; 7 &amp;&amp; this.count / this.limit &lt; this.minLoadFactor) { this.resize(this.getPrime(Math.floor(this.limit / 2))); } return tuple; } } } isEmpty() { return this.count === 0; } size() { return this.count; } // 重新调整哈希表大小，扩容或压缩 resize(newLimit) { // 1、保存旧的 storage 数组内容 const oldStorage = this.storage; // 2、重置所有属性 this.storage = []; this.count = 0; this.limit = newLimit; // 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage for (const bucket of oldStorage) { if (bucket) { for (const b of bucket) { this.put(b[0], b[1]); } } } } }  "},{"title":"集合（Set）","type":0,"sectionRef":"#","url":"/interview/docs-data/集合（Set）","content":"","keywords":""},{"title":"什么是集合​","type":1,"pageTitle":"集合（Set）","url":"/interview/docs-data/集合（Set）#什么是集合","content":"几乎每种编程语言中，都有集合结构。集合比较常见的实现方式是哈希表，这里使用 JavaScript 的 Object 进行封装。 特点 集合通常是由一组无序的、不能重复的元素构成。数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复。集合是特殊的数组。 特殊之处在于里面的元素没有顺序，也不能重复。没有顺序意味着不能通过下标值进行访问，不能重复意味着相同的对象在集合中只会存在一份。 "},{"title":"集合的封装​","type":1,"pageTitle":"集合（Set）","url":"/interview/docs-data/集合（Set）#集合的封装","content":"ES6 中的 Set 就是一个集合类，这里我们重新封装一个 Set 类，了解集合的底层实现。 "},{"title":"集合的常见方法​","type":1,"pageTitle":"集合（Set）","url":"/interview/docs-data/集合（Set）#集合的常见方法","content":"add(value) 向集合添加一个新的项。remove(value) 从集合移除一个值。has(value) 如果值在集合中，返回 true，否则返回 false。clear() 移除集合中的所有项。size() 返回集合所包含元素的数量。与数组的 length 属性类似。values() 返回一个包含集合中所有值的数组。还有其他的方法，用的不多，这里不做封装。 "},{"title":"封装集合​","type":1,"pageTitle":"集合（Set）","url":"/interview/docs-data/集合（Set）#封装集合","content":"// 集合结构的封装 class Set { constructor() { this.items = {} } // has(value) 判断集合中是否存在 value 值，存在返回 true，否则返回 false has(value) { return this.items.hasOwnProperty(value) } // add(value) 往集合中添加 value add(value) { if (this.has(value)) return false this.items[value] = value return true } // remove(value) 删除集合中指定的 value remove(value) { // 如果集合不存在该 value，返回 false if (!this.has(value)) return false delete this.items[value] } // clear() 清空集合中所有 value clear() { this.items = {} } // size() 获取集合中的 value 个数 size() { return Object.keys(this.items).length } // values() 获取集合中所有的 value values() { return Object.keys(this.items) } } // 测试 const set = new Set() // add() 测试 set.add('abc') set.add('abc') set.add('123') set.add('zxc') console.log(set) //--&gt; {items: {123: &quot;123&quot;, abc: &quot;abc&quot;, zxc: &quot;zxc&quot;}} // has() 测试 console.log(set.has('123')) //--&gt; true console.log(set.has('456')) //--&gt; false // remove() 测试 set.remove('abc') console.log(set) //--&gt; {items: {123: &quot;123&quot;, zxc: &quot;zxc&quot;}} // size() 测试 console.log(set.size()) //--&gt; 2 // values() 测试 console.log(set.values()) //--&gt; [&quot;123&quot;, &quot;zxc&quot;] // clear() 测试 set.clear() console.log(set.values()) //--&gt; []  "},{"title":"集合间的操作​","type":1,"pageTitle":"集合（Set）","url":"/interview/docs-data/集合（Set）#集合间的操作","content":"并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。子集：验证一个给定集合是否是另一个集合的子集。  "},{"title":"并集的实现​","type":1,"pageTitle":"集合（Set）","url":"/interview/docs-data/集合（Set）#并集的实现","content":"// union() 求两个集合的并集 union(otherSet) { // 1、创建一个新集合 let unionSet = new Set(); // 2、将当前集合（this）的所有 value，添加到新集合（unionSet）中 for (let value of this.values()) { unionSet.add(value); } // 3、将 otherSet 集合的所有 value，添加到新集合（unionSet）中 for (let value of otherSet.values()) { unionSet.add(value); // add() 已经有重复判断 } return unionSet; }  "},{"title":"交集的实现​","type":1,"pageTitle":"集合（Set）","url":"/interview/docs-data/集合（Set）#交集的实现","content":"// intersection() 求两个集合的交集 intersection(otherSet) { // 1、创建一个新集合 let intersectionSet = new Set(); // 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在 for (let value of this.values()) { if (otherSet.has(value)) { intersectionSet.add(value); } } return intersectionSet; }  "},{"title":"差集的实现​","type":1,"pageTitle":"集合（Set）","url":"/interview/docs-data/集合（Set）#差集的实现","content":"// difference() 差集 difference(otherSet) { // 1、创建一个新集合 let differenceSet = new Set(); // 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，不存在的即为差集 for (let value of this.values()) { if (!otherSet.has(value)) { differenceSet.add(value); } } return differenceSet; }  "},{"title":"子集的实现​","type":1,"pageTitle":"集合（Set）","url":"/interview/docs-data/集合（Set）#子集的实现","content":"// subset() 子集 subset(otherSet) { // 从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，有不存在的返回 false // 遍历完所有的，返回 true for (let value of this.values()) { if (!otherSet.has(value)) { return false; } } return true; }  "},{"title":"完整实现​","type":1,"pageTitle":"集合（Set）","url":"/interview/docs-data/集合（Set）#完整实现","content":"// 集合结构的封装 export default class Set { constructor() { this.items = {} } // has(value) 判断集合中是否存在 value 值，存在返回 true，否则返回 false has(value) { return this.items.hasOwnProperty(value) } // add(value) 往集合中添加 value add(value) { if (this.has(value)) return false this.items[value] = value return true } // remove(value) 删除集合中指定的 value remove(value) { // 如果集合不存在该 value，返回 false if (!this.has(value)) return false delete this.items[value] } // clear() 清空集合中所有 value clear() { this.items = {} } // size() 获取集合中的 value 个数 size() { return Object.keys(this.items).length } // values() 获取集合中所有的 value values() { return Object.keys(this.items) } // ------- 集合间的操作 ------- // // union() 求两个集合的并集 union(otherSet) { // 1、创建一个新集合 let unionSet = new Set() // 2、将当前集合（this）的所有 value，添加到新集合（unionSet）中 for (let value of this.values()) { unionSet.add(value) } // 3、将 otherSet 集合的所有 value，添加到新集合（unionSet）中 for (let value of otherSet.values()) { unionSet.add(value) // add() 已经有重复判断 } return unionSet } // intersection() 求两个集合的交集 intersection(otherSet) { // 1、创建一个新集合 let intersectionSet = new Set() // 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在 for (let value of this.values()) { if (otherSet.has(value)) { intersectionSet.add(value) } } return intersectionSet } // difference() 差集 difference(otherSet) { // 1、创建一个新集合 let differenceSet = new Set() // 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，不存在的即为差集 for (let value of this.values()) { if (!otherSet.has(value)) { differenceSet.add(value) } } return differenceSet } // subset() 子集 subset(otherSet) { // 从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，有不存在的返回 false // 遍历完所有的，返回 true for (let value of this.values()) { if (!otherSet.has(value)) { return false } } return true } }  "},{"title":"树","type":0,"sectionRef":"#","url":"/interview/docs-data/树","content":"","keywords":""},{"title":"什么是树​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#什么是树","content":"一棵树具有以下特点： 一棵树中的任意两个结点有且仅有唯一的一条路径连通。一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。一棵树不包含回路。 现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转 180° 的树。  下图就是一颗树，并且是一颗二叉树。  如上图所示，通过上面这张图说明一下树中的常用概念： 节点 ：树中的每个元素都可以统称为节点。根节点 ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。父节点 ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。子节点 ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。兄弟节点 ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。叶子节点 ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。节点的高度 ：该节点到叶子节点的最长路径所包含的边数。节点的深度 ：根节点到该节点的路径所包含的边数节点的层数 ：节点的深度+1。树的高度 ：根节点的高度。 关于树的深度和高度的定义可以看 stackoverflow 上的这个问题：What is the difference between tree depth and height?open in new window 。 "},{"title":"数组、链表、哈希表和树的对比​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#数组链表哈希表和树的对比","content":"数组： 优点：可以通过下标值访问，效率高；缺点：查找数据时需要先对数据进行排序，生成有序数组，才能提高查找效率；并且在插入和删除元素时，需要大量的位移操作； 链表： 优点：数据的插入和删除操作效率都很高；缺点：查找效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。 哈希表： 优点：哈希表的插入/查询/删除效率都非常高；缺点：空间利用率不高，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是无序的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中最大值或最小值这些特殊值。 树结构： 优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。 总的来说：每种数据结构都有自己特定的应用场景。 树结构： 树（Tree）：由 n（n ≥ 0）个节点构成的有限集合。当 n = 0 时，称为空树。对于任意一棵非空树（n &gt; 0），它具备以下性质： 数中有一个称为根（Root）的特殊节点，用 r 表示；其余节点可分为 m（m &gt; 0）个互不相交的有限集合 T1，T2，…，Tm，其中每个集合本身又是一棵树，称为原来树的子树（SubTree）。’ "},{"title":"树的常用术语​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#树的常用术语","content":" 节点的度（Degree）：节点的子树个数，比如节点 B 的度为 2；树的度：树的所有节点中最大的度数，如上图树的度为 2；叶节点（Leaf）：度为 0 的节点（也称为叶子节点）（没有子节点的节点），如上图的 H，I 等；父节点（Parent）：度不为 0 的节点称为父节点，如上图节点 B 是节点 D 和 E 的父节点；子节点（Child）：若 B 是 D 的父节点，那么 D 就是 B 的子节点；兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点，比如上图的 B 和 C，D 和 E 互为兄弟节点；路径和路径长度：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如 A-&gt;H 的路径长度为 3；节点的层次（Level）：规定根节点在 1 层，其他任一节点的层数是其父节点的层数加 1。如 B 和 C 节点的层次为 2；树的深度（Depth）：树种所有节点中的最大层次是这棵树的深度，如上图树的深度为 4（层数）； "},{"title":"树结构的表示方法​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#树结构的表示方法","content":""},{"title":"最普通的表示方法​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#最普通的表示方法","content":" 如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点 A 需要 3 个引用，分别指向子节点 B，C，D；B 节点需要 2 个引用，分别指向子节点 E 和 F；K 节点由于没有子节点，所以不需要引用。 这种方法缺点在于我们无法确定某一结点的引用数。 "},{"title":"儿子-兄弟表示法​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#儿子-兄弟表示法","content":" 这种表示方法可以完整地记录每个节点的数据，比如： Node{ //存储数据 this.data = data //统一只记录左边的子节点 this.leftChild = B //统一只记录右边的第一个兄弟节点 this.rightSibling = null } //节点B Node{ this.data = data this.leftChild = E this.rightSibling = C } //节点F Node{ this.data = data this.leftChild = null this.rightSibling = null }  这种表示法的优点在于每一个节点中引用的数量都是确定的。 "},{"title":"儿子-兄弟表示法旋转​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#儿子-兄弟表示法旋转","content":"以下为儿子-兄弟表示法组成的树结构：  将其顺时针旋转 45° 之后：  这样就成为了一棵二叉树，由此我们可以得出结论：任何树都可以通过二叉树进行模拟。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。 "},{"title":"二叉树​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#二叉树","content":"如果树中的每一个节点最多只能由两个子节点，这样的树就称为二叉树(最多两个子节点、左孩子和右孩子)； 二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。 二叉树 的分支通常被称作“左子树”或“右子树”。并且，二叉树 的分支具有左右次序，不能随意颠倒。 二叉树 的第 i 层至多拥有 2^(i-1) 个节点，深度为 k 的二叉树至多总共有 2^(k+1)-1 个节点（满二叉树的情况），至少有 2^(k) 个节点（关于节点的深度的定义国内争议比较多，我个人比较认可维基百科对节点深度的定义open in new window）。  "},{"title":"二叉树的组成​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#二叉树的组成","content":"二叉树可以为空，也就是没有节点；若二叉树不为空，则它由根节点和称为其左子树 TL 和右子树 TR 的两个不相交的二叉树组成； "},{"title":"二叉树的五种形态​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#二叉树的五种形态","content":" 上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树 TL 的二叉树、只有右子树 TR 的二叉树和有左右两个子树的二叉树。 "},{"title":"二叉树的特性​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#二叉树的特性","content":"一个二叉树的第 i 层的最大节点数为（第i层最多有多少个节点）：2^(i-1)，i &gt;= 1；深度为 k 的二叉树的最大节点总数为：2^k - 1（2的k次方 - 1） ，k &gt;= 1,最小为2^(k-1)（2的k-1次方）；对任何非空二叉树，若 n0 表示叶子节点的个数，n2表示度为 2 的非叶子节点个数，那么两者满足关系：n0 = n2 + 1；如下图所示：H，E，I，J，G 为叶子节点，总数为 5；A，B，C，F 为度为 2 的非叶子节点，总数为 4；满足 n0 = n2 + 1 的规律。  "},{"title":"二叉树的分类​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#二叉树的分类","content":""},{"title":"满二叉树（完美二叉树）​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#满二叉树完美二叉树","content":"完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有 2 个子节点，这就构成了完美二叉树，换一种说法，一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 满二叉树。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 满二叉树。如下图所示：  "},{"title":"完全二叉树​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#完全二叉树","content":"完全二叉树（Complete Binary Tree）: 除了二叉树 最后一层 外，其他各层的节点数都达到了最大值； 并且，最后一层的 叶子节点从左向右是连续存在 ，只缺失右侧若干叶子节点（注意：此处的右侧非根节点的右侧，而是当前连续的左右的右）； 百度百科：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。 完美二叉树是特殊的完全二叉树；  在上图中，由于 H 缺失了右子节点，所以它不是完全二叉树。 完全二叉树有一个很好的性质：父结点和子节点的序号有着对应关系。 细心的小伙伴可能发现了，当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。 "},{"title":"平衡二叉树​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#平衡二叉树","content":"平衡二叉树 是一棵二叉排序树，且具有以下性质： 可以是一棵空树如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。 平衡二叉树的常用实现方法有 红黑树、AVL 树、替罪羊树、加权平衡树、伸展树 等。 二叉搜索树的缺陷：当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树由 11 7 15 组成，如下图所示：  当插入一组有序数据：6 5 4 3 2 就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。  非平衡树 比较好的二叉搜索树，它的数据应该是左右均匀分布的。但是插入连续数据后，二叉搜索树中的数据分布就变得不均匀了，我们称这种树为非平衡树。对于一棵平衡二叉树来说，插入/查找等操作的效率是 O(log n)。而对于一棵非平衡二叉树来说，相当于编写了一个链表，查找效率变成了 O(n)。 树的平衡性 为了能以较快的时间 O(log n)来操作一棵树，我们需要保证树总是平衡的： 起码大部分是平衡的，此时的时间复杂度也是接近 O(log n) 的；这就要求树中每个节点左边的子孙节点的个数，应该尽可能地等于右边的子孙节点的个数； 常见的平衡树 AVL 树：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于 AVL 树是平衡树，所以它的时间复杂度也是 O(log n)。但是它的整体效率不如红黑树，开发中比较少用。红黑树：同样通过一些特性来保持树的平衡，时间复杂度也是 O(log n)。进行插入/删除等操作时，性能优于 AVL 树，所以平衡树的应用基本都是红黑树。 "},{"title":"哈夫曼树​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#哈夫曼树","content":"什么是哈夫曼树​  带权路径长度​  哈夫曼树的构造​   哈夫曼编码​ 哈夫曼编码，每种字符用一串二进制表示，出现频率越高表示位数越少   练习题   "},{"title":"二叉搜索/排序/查找树​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#二叉搜索排序查找树","content":"二叉搜索树（BST，Binary Search Tree），也称为二叉排序树和二叉查找树。 二叉搜索树是一棵二叉树，可以为空。 如果不为空，则满足以下性质：（） 条件 1：非空左子树的所有键值小于其根节点的键值。比如三中节点 6 的所有非空左子树的键值都小于 6； 条件 2：非空右子树的所有键值大于其根节点的键值；比如三中节点 6 的所有非空右子树的键值都大于 6； 条件 3：左、右子树本身也都是二叉搜索树； 简而言之，就是每个左子节点必须小于其父节点，右子节点必须大于其父节点 简而言之，就是 左子树（所有值小于根节点）：每个左子节点必须小于其父节点，右子节点必须大于其父节点且小于整个树的根节点 右子树（所有值大于根节点）：每个左子节点必须小于其父节点且大于整个树的根节点，右子节点必须大于其父节点  如上图所示，树二和树三符合 3 个条件属于二叉树，树一不满足条件 3 所以不是二叉树。 总结：二叉搜索树的特点主要是较小的值总是保存在左节点上，相对较大的值总是保存在右节点上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中“搜索”的来源。 二叉搜索树应用举例​ 下面是一个二叉搜索树：  若想在其中查找数据 10，只需要查找 4 次，查找效率非常高。 第 1 次：将 10 与根节点 9 进行比较，由于 10 &gt; 9，所以 10 下一步与根节点 9 的右子节点 13 比较；第 2 次：由于 10 &lt; 13，所以 10 下一步与父节点 13 的左子节点 11 比较；第 3 次：由于 10 &lt; 11，所以 10 下一步与父节点 11 的左子节点 10 比较；第 4 次：由于 10 = 10，最终查找到数据 10 。  同样是 15 个数据，在排序好的数组中查询数据 10，需要查询 10 次：  其实：如果是排序好的数组，可以通过二分查找：第一次找 9，第二次找 13，第三次找 15…。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是二叉搜索树。这就是数组二分法查找效率之所以高的原因。 二叉搜索树的常见操作​ insert(key) 向树中插入一个新的键。search(key) 在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 false。preOrderTraverse 通过先序遍历方式遍历所有节点。inOrderTraverse 通过中序遍历方式遍历所有节点。postOrderTraverse 通过后序遍历方式遍历所有节点。min 返回树中最小的值/键。max 返回树中最大的值/键。remove(key) 从树中移除某个键。 二叉搜索树的封装​ 二叉搜索树有四个最基本的属性：指向节点的根（root），节点中的键（key）、左指针（right）、右指针（right）。  所以，二叉搜索树中除了定义 root 属性外，还应定义一个节点内部类，里面包含每个节点中的 left、right 和 key 三个属性。 // 节点类 class Node { constructor(key) { this.key = key; this.left = null; this.right = null; } }  实现insert()方法​ 实现思路： 首先根据传入的 key 创建节点对象。然后判断根节点是否存在，不存在时通过：this.root = newNode，直接把新节点作为二叉搜索树的根节点。若存在根节点则重新定义一个内部方法 insertNode() 用于查找插入点。 insert(key) 代码实现 // insert(key) 插入数据 insert(key) { const newNode = new Node(key); if (this.root === null) { this.root = newNode; } else { this.insertNode(this.root, newNode); } }  实现insertNode()方法​ 实现思路 根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。 当 newNode.key &lt; node.key 向左查找: 情况 1：当 node 无左子节点时，直接插入：情况 2：当 node 有左子节点时，递归调用 insertNode()，直到遇到无左子节点成功插入 newNode 后，不再符合该情况，也就不再调用 insertNode()，递归停止。 当 newNode.key &gt;= node.key 向右查找，与向左查找类似： 情况 1：当 node 无右子节点时，直接插入：情况 2：当 node 有右子节点时，依然递归调用 insertNode()，直到遇到传入 insertNode 方法 的 node 无右子节点成功插入 newNode 为止。 insertNode(root, node) 代码实现 insertNode(root, node) { if (node.key &lt; root.key) { // 往左边查找插入 if (root.left === null) { root.left = node; } else { this.insertNode(root.left, node); } } else { // 往右边查找插入 if (root.right === null) { root.right = node; } else { this.insertNode(root.right, node); } } }  实现min()和max()方法​ 查找最大值和最小值 在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值，如下图所示：  // min() 获取二叉搜索树最小值 min() { if (!this.root) return null; let node = this.root; while (node.left !== null) { node = node.left; } return node.key; } // max() 获取二叉搜索树最大值 max() { if (!this.root) return null; let node = this.root; while (node.right !== null) { node = node.right; } return node.key; }  实现查找特定值​ 查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的 key 值与之比较，若 node.key &lt; root 则向左查找，若 node.key &gt; root 就向右查找，直到找到或查找到 null 为止。这里可以使用递归实现，也可以采用循环来实现。 // search(key) 查找二叉搜索树中是否有相同的key，存在返回 true，否则返回 false search(key) { return this.searchNode(this.root, key); } // 通过递归实现 searchNode(node, key) { if (node === null) return false; if (key &lt; node.key) { return this.searchNode(node.left, key); } else if (key &gt; node.key) { return this.searchNode(node.right, key); } else { return true; } } // 通过 while 循环实现 search2(key) { let node = this.root; while (node !== null) { if (key &lt; node.key) { node = node.left; } else if (key &gt; node.key) { node = node.right; } else { return true; } } return false; }  实现删除数据​ 实现思路： 第一步：先找到需要删除的节点，若没找到，则不需要删除； 首先定义变量 current 用于保存需要删除的节点、变量 parent 用于保存它的父节点、变量 isLeftChild 保存 current 是否为 parent 的左节点，这样方便之后删除节点时改变相关节点的指向。 let currentNode = this.root; let parentNode = null; let isLeftChild = true; // 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild while (currentNode.key !== key) { parentNode = currentNode; // 小于，往左查找 if (key &lt; currentNode.key) { isLeftChild = true; currentNode = currentNode.left; } else { // 否则往右查找 isLeftChild = false; currentNode = currentNode.right; } // 找到最后都没找到相等的节点，返回 false if (currentNode === null) { return false; } }  第二步：删除找到的指定节点，后分 3 种情况： 删除的是叶子节点；删除的是只有一个子节点的节点；删除的是有两个子节点的节点； 删除的是叶子节点​ 删除的是叶子节点分两种情况： 叶子节点也是根节点 当该叶子节点为根节点时，如下图所示，此时 current == this.root，直接通过：this.root = null，删除根节点。 叶子节点不为根节点 当该叶子节点不为根节点时也有两种情况，如下图所示 若 current = 8，可以通过：parent.left = null，删除节点 8； 若 current = 10，可以通过：parent.right = null，删除节点 10；  // 1、删除的是叶子节点的情况 if (currentNode.left === null &amp;&amp; currentNode.right === null) { if (currentNode === this.root) { this.root = null; } else if (isLeftChild) { parentNode.left = null; } else { parentNode.right = null; } // 2、删除的是只有一个子节点的节点 }  删除的是只有一个子节点的节点​ 有六种情况： 当 current 存在左子节点时（current.right == null）： 情况 1：current 为根节点（current == this.root），如节点 11，此时通过：this.root = current.left，删除根节点 11；情况 2：current 为父节点 parent 的左子节点（isLeftChild == true），如节点 5，此时通过：parent.left = current.left，删除节点 5；情况 3：current 为父节点 parent 的右子节点（isLeftChild == false），如节点 9，此时通过：parent.right = current.left，删除节点 9；  当 current 存在右子节点时（current.left = null）： 情况 4：current 为根节点（current == this.root），如节点 11，此时通过：this.root = current.right，删除根节点 11。情况 5：current 为父节点 parent 的左子节点（isLeftChild == true），如节点 5，此时通过：parent.left = current.right，删除节点 5；情况 6：current 为父节点 parent 的右子节点（isLeftChild == false），如节点 9，此时通过：parent.right = current.right，删除节点 9；  // 2、删除的是只有一个子节点的节点 } else if (currentNode.right === null) { // currentNode 只存在左节点 //-- 2.1、currentNode 只存在&lt;左节点&gt;的情况 //---- 2.1.1、currentNode 等于 root //---- 2.1.2、parentNode.left 等于 currentNode //---- 2.1.3、parentNode.right 等于 currentNode if (currentNode === this.root) { this.root = currentNode.left; } else if (isLeftChild) { parentNode.left = currentNode.left; } else { parentNode.right = currentNode.left; } } else if (currentNode.left === null) { // currentNode 只存在右节点 //-- 2.2、currentNode 只存在&lt;右节点&gt;的情况 //---- 2.1.1 currentNode 等于 root //---- 2.1.1 parentNode.left 等于 currentNode //---- 2.1.1 parentNode.right 等于 currentNode if (currentNode === this.root) { this.root = currentNode.right; } else if (isLeftChild) { parentNode.left = currentNode.right; } else { parentNode.right = currentNode.right; }  删除的是有两个子节点的节点​ 这种情况十分复杂，首先依据以下二叉搜索树，讨论这样的问题：  删除节点 9 在保证删除节点 9 后原二叉树仍为二叉搜索树的前提下，有两种方式： 方式 1：从节点 9 的左子树中选择一合适的节点替代节点 9，可知节点 8 符合要求；方式 2：从节点 9 的右子树中选择一合适的节点替代节点 9，可知节点 10 符合要求；  删除节点 7 在保证删除节点 7 后原二叉树仍为二叉搜索树的前提下，也有两种方式： 方式 1：从节点 7 的左子树中选择一合适的节点替代节点 7，可知节点 5 符合要求；方式 2：从节点 7 的右子树中选择一合适的节点替代节点 7，可知节点 8 符合要求；  删除节点 15 在保证删除节点 15 后原树二叉树仍为二叉搜索树的前提下，同样有两种方式： 方式 1：从节点 15 的左子树中选择一合适的节点替代节点 15，可知节点 14 符合要求；方式 2：从节点 15 的右子树中选择一合适的节点替代节点 15，可知节点 18 符合要求；  相信你已经发现其中的规律了！ 规律总结：如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点下面的子节点中找到一个合适的节点，来替换当前的节点。 若用 current 表示需要删除的节点，则合适的节点指的是： current 左子树中比 current 小一点点的节点，即 current 左子树中的最大值；current 右子树中比 current 大一点点的节点，即 current 右子树中的最小值； 前驱&amp;后继​ 在二叉搜索树中，这两个特殊的节点有特殊的名字： 比 current 小一点点的节点，称为 current 节点的前驱。比如下图中的节点 5 就是节点 7 的前驱；比 current 大一点点的节点，称为 current 节点的后继。比如下图中的节点 8 就是节点 7 的后继；  查找需要被删除的节点 current 的后继时，需要在 current 的右子树中查找最小值，即在 current 的右子树中一直向左遍历查找； 查找前驱时，则需要在 current 的左子树中查找最大值，即在 current 的左子树中一直向右遍历查找。 下面只讨论查找 current 后继的情况，查找前驱的原理相同，这里暂不讨论。 // 3、删除的是有两个子节点的节点 } else { // 1、找到后续节点 let successor = this.getSuccessor(currentNode); // 2、判断是否为根节点 if (currentNode === this.root) { this.root = successor; } else if (isLeftChild) { parentNode.left = successor; } else { parentNode.right = successor; } // 3、将后续的左节点改为被删除的左节点 successor.left = currentNode.left; } } // 获取后续节点，即从要删除的节点的右边开始查找最小的值 getSuccessor(delNode) { // 定义变量，保存要找到的后续 let successor = delNode; let current = delNode.right; let successorParent = delNode; // 循环查找 current 的右子树节点 while (current !== null) { successorParent = successor; successor = current; current = current.left; } // 判断寻找到的后续节点是否直接就是要删除节点的 right if (successor !== delNode.right) { successorParent.left = successor.right; successor.right = delNode.right; } return successor; }  完整实现​ // 删除节点 remove(key) { let currentNode = this.root; let parentNode = null; let isLeftChild = true; // 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild while (currentNode.key !== key) { parentNode = currentNode; // 小于，往左查找 if (key &lt; currentNode.key) { isLeftChild = true; currentNode = currentNode.left; } else { // 否则往右查找 isLeftChild = false; currentNode = currentNode.right; } // 找到最后都没找到相等的节点，返回 false if (currentNode === null) { return false; } } // 1、删除的是叶子节点的情况 if (currentNode.left === null &amp;&amp; currentNode.right === null) { if (currentNode === this.root) { this.root = null; } else if (isLeftChild) { parentNode.left = null; } else { parentNode.right = null; } // 2、删除的是只有一个子节点的节点 } else if (currentNode.right === null) { // currentNode 只存在左节点 //-- 2.1、currentNode 只存在&lt;左节点&gt;的情况 //---- 2.1.1、currentNode 等于 root //---- 2.1.2、parentNode.left 等于 currentNode //---- 2.1.3、parentNode.right 等于 currentNode if (currentNode === this.root) { this.root = currentNode.left; } else if (isLeftChild) { parentNode.left = currentNode.left; } else { parentNode.right = currentNode.left; } } else if (currentNode.left === null) { // currentNode 只存在右节点 //-- 2.2、currentNode 只存在&lt;右节点&gt;的情况 //---- 2.1.1 currentNode 等于 root //---- 2.1.1 parentNode.left 等于 currentNode //---- 2.1.1 parentNode.right 等于 currentNode if (currentNode === this.root) { this.root = currentNode.right; } else if (isLeftChild) { parentNode.left = currentNode.right; } else { parentNode.right = currentNode.right; } // 3、删除的是有两个子节点的节点 } else { // 1、找到后续节点 let successor = this.getSuccessor(currentNode); // 2、判断是否为根节点 if (currentNode === this.root) { this.root = successor; } else if (isLeftChild) { parentNode.left = successor; } else { parentNode.right = successor; } // 3、将后续的左节点改为被删除的左节点 successor.left = currentNode.left; } } // 获取后续节点，即从要删除的节点的右边开始查找最小的值 getSuccessor(delNode) { // 定义变量，保存要找到的后续 let successor = delNode; let current = delNode.right; let successorParent = delNode; // 循环查找 current 的右子树节点 while (current !== null) { successorParent = successor; successor = current; current = current.left; } // 判断寻找到的后续节点是否直接就是要删除节点的 right if (successor !== delNode.right) { successorParent.left = successor.right; successor.right = delNode.right; } return successor; }  练习题​    从左往右，如果下一个数比根节点（父节点）大，则放在右边，小则放在左边 注意：左边的值不能比根节点（父节点）大 例如：  "},{"title":"二叉树的遍历​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#二叉树的遍历","content":"这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为： 先序遍历；中序遍历；后序遍历； 还有层序遍历，使用较少。 "},{"title":"先序遍历​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#先序遍历","content":"先序遍历的过程为： 先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则， 每个节点都遵循上述规则，也就是说，我们可以递归实现先序遍历。  如上图所示，二叉树的节点遍历顺序为：A -&gt; B -&gt; D -&gt; H -&gt; I -&gt; E -&gt; C -&gt; F -&gt; G。  代码实现​ // 先序遍历（根左右 DLR） preorderTraversal() { const result = []; this.preorderTraversalNode(this.root, result); return result; } preorderTraversalNode(node, result) { if (node === null) return result; result.push(node.key); this.preorderTraversalNode(node.left, result); this.preorderTraversalNode(node.right, result); }  "},{"title":"中序遍历​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#中序遍历","content":"实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。 首先，遍历其左子树；然后，遍历根（父）节点；最后，遍历其右子树； 或者是 先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树， 过程图解：  输出节点的顺序应为：3 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 14 -&gt; 15 -&gt; 18 -&gt; 20 -&gt; 25 。  大家可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间，如下图所示：  代码实现​ // 中序遍历（左根右 LDR） inorderTraversal() { const result = []; this.inorderTraversalNode(this.root, result); return result; } inorderTraversalNode(node, result) { if (node === null) return result; this.inorderTraversalNode(node.left, result); result.push(node.key); this.inorderTraversalNode(node.right, result); }  "},{"title":"后序遍历​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#后序遍历","content":"实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。 首先，遍历其左子树；然后，遍历其右子树；最后，遍历根（父）节点； （就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值） 过程图解：  输出节点的顺序应为：3 -&gt; 6 -&gt; 5 -&gt; 8 -&gt; 10 -&gt; 9 -&gt; 7 -&gt; 12 -&gt; 14 -&gt; 13 -&gt; 18 -&gt; 25 -&gt; 20 -&gt; 15 -&gt; 11 。  代码实现​ // 后序遍历（左右根 LRD） postorderTraversal() { const result = []; this.postorderTraversalNode(this.root, result); return result; } postorderTraversalNode(node, result) { if (node === null) return result; this.postorderTraversalNode(node.left, result); this.postorderTraversalNode(node.right, result); result.push(node.key); }  总结​ 以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。 "},{"title":"二叉树的数据存储​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#二叉树的数据存储","content":"常见的二叉树存储方式为数组和链表： "},{"title":"使用数组​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#使用数组","content":"完全二叉树：按从上到下，从左到右的方式存储数据。  节点\tA\tB\tC\tD\tE\tF\tG\tH\tI序号\t1\t2\t3\t4\t5\t6\t7\t8\t9 使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 2，右子节点的序号等于父节点序号 2 + 1 (D = B 2 E = B 2 + 1)。 非完全二叉树：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。  节点\tA\tB\tC\t^\t^\tF\t^\t^\t^\t^\t^\t^\tM序号\t1\t2\t3\t4\t5\t6\t7\t8\t9\t10\t11\t12\t13 "},{"title":"使用链表​","type":1,"pageTitle":"树","url":"/interview/docs-data/树#使用链表","content":"二叉树最常见的存储方式为链表：每一个节点封装成一个 Node，Node 中包含存储的数据、左节点的引用和右节点的引用。  "},{"title":"链表","type":0,"sectionRef":"#","url":"/interview/docs-data/链表","content":"","keywords":""},{"title":"什么是链表​","type":1,"pageTitle":"链表","url":"/interview/docs-data/链表#什么是链表","content":"链表和数组一样，可以用于存储一系列的元素，但是链表和数组的实现机制完全不同。 链表（LinkedList） 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。 链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。 使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。 链表操作的时间复杂度分析 假如链表中有n个元素。 访问：O（n）// 访问特定位置的元素 插入删除：O（1）// 必须要要知道插入元素的位置  "},{"title":"链表和数组的对比​","type":1,"pageTitle":"链表","url":"/interview/docs-data/链表#链表和数组的对比","content":"数组支持随机访问，而链表不支持。数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！ 数组 存储多个元素，数组（或列表）可能是最常用的数据结构。 几乎每一种编程语言都有默认实现数组结构，提供了一个便利的 [] 语法来访问数组元素。 数组缺点： 数组的创建需要申请一段连续的内存空间(一整块内存)，并且大小是固定的，当前数组不能满足容量需求时，需要扩容。 (一般情况下是申请一个更大的数组，比如 2 倍，然后将原数组中的元素复制过去) 在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。  链表  存储多个元素，另外一个选择就是使用链表。 不同于数组，链表中的元素在内存中不必是连续的空间。 链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针)组成。 链表优点： 内存空间不必是连续的，可以充分利用计算机的内存，实现灵活的内存动态管理。 链表不必在创建时就确定大小，并且大小可以无限延伸下去。 链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对数组效率高很多。 链表缺点： 访问任何一个位置的元素时，需要从头开始访问。(无法跳过第一个元素访问任何一个元素) 无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。 虽然可以轻松地到达下一个节点，但是回到前一个节点是很难的。 "},{"title":"链表的分类​","type":1,"pageTitle":"链表","url":"/interview/docs-data/链表#链表的分类","content":"常见链表分类： 单链表双向链表循环链表双向循环链表 "},{"title":"单向链表​","type":1,"pageTitle":"链表","url":"/interview/docs-data/链表#单向链表","content":"单链表 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。  单向链表类似于火车，有一个火车头，火车头会连接一个节点，节点上有乘客，并且这个节点会连接下一个节点，以此类推。 链表的火车结构 链表的数据结构 head 属性指向链表的第一个节点。 链表中的最后一个节点指向 null。 当链表中一个节点也没有的时候，head 直接指向 null。 给火车加上数据后的结构 单向链表的常用方法​ append(element) 向链表尾部添加一个新的项。insert(position, element) 向链表的特定位置插入一个新的项。get(position) 获取对应位置的元素。indexOf(element) 返回元素在链表中的索引。如果链表中没有该元素就返回-1。update(position, element) 修改某个位置的元素。removeAt(position) 从链表的特定位置移除一项。remove(element) 从链表中移除一项。isEmpty() 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。size() 返回链表包含的元素个数，与数组的 length 属性类似。toString() 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。 单向链表的封装​ 创建单向链表类​ 先创建单向链表类 LinkedList，添加基本属性，再逐步实现单向链表的常用方法。 class LinkedList { // 初始链表长度为 0 length = 0; // 初始 head 为 null，head 指向链表的第一个节点 head = null; // 内部类（链表里的节点 Node） Node = class { data; next = null; constructor(data) { this.data = data; } }; }  实现append()方法​ // append() 往链表尾部追加数据 append(data) { // 1、创建新节点 const newNode = new this.Node(data); // 2、追加新节点 if (this.length === 0) { // 链表长度为 0 时，即只有 head 的时候 this.head = newNode; } else { // 链表长度大于 0 时，在最后面添加新节点 let currentNode = this.head; // 当 currentNode.next 不为空时， // 循序依次找最后一个节点，即节点的 next 为 null 时 while (currentNode.next !== null) { currentNode = currentNode.next; } // 最后一个节点的 next 指向新节点 currentNode.next = newNode; } // 3、追加完新节点后，链表长度 + 1 this.length++; } // 测试 const linkedList = new LinkedList(); linkedList.append(&quot;A&quot;); linkedList.append(&quot;B&quot;); linkedList.append(&quot;C&quot;); console.log(linkedList);  过程图解 首先让 currentNode 指向第一个节点。 通过 while 循环使 currentNode 指向最后一个节点，最后通过 currentNode.next = newNode，让最后一个节点指向新节点 newNode。  实现toString()方法​ toString() { let currentNode = this.head; let result = ''; // 遍历所有的节点，拼接为字符串，直到节点为 null while (currentNode) { result += currentNode.data + ' '; currentNode = currentNode.next; } return result; } // 测试 toString 方法 console.log(linkedList.toString()); //--&gt; AA BB CC  实现insert()方法​ // insert() 在指定位置（position）插入节点 insert(position, data) { // position 新插入节点的位置 // position = 0 表示新插入后是第一个节点 // position = 1 表示新插入后是第二个节点，以此类推 // 1、对 position 进行越界判断，不能小于 0 或大于链表长度 if (position &lt; 0 || position &gt; this.length) return false; // 2、创建新节点 const newNode = new this.Node(data); // 3、插入节点 if (position === 0) { // position = 0 的情况 // 让新节点的 next 指向 原来的第一个节点，即 head newNode.next = this.head; // head 赋值为 newNode this.head = newNode; } else { // 0 &lt; position &lt;= length 的情况 // 初始化一些变量 let currentNode = this.head; // 当前节点初始化为 head let previousNode = null; // head 的 上一节点为 null let index = 0; // head 的 index 为 0 // 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode // 直到找到要插入的位置 while (index++ &lt; position) { previousNode = currentNode; currentNode = currentNode.next; } // 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向 newNode.next = currentNode; previousNode.next = newNode; } // 更新链表长度 this.length++; return newNode; } // 测试 insert 方法 linkedList.insert(0, &quot;123&quot;); linkedList.insert(2, &quot;456&quot;); console.log(linkedList.toString()); //--&gt; 123 AA 456 BB CC  实现getData()方法​ 获取指定位置（position）的 data。 getData(position) { // 1、position 越界判断 if (position &lt; 0 || position &gt;= this.length) return null; // 2、获取指定 position 节点的 data let currentNode = this.head; let index = 0; while (index++ &lt; position) { currentNode = currentNode.next; } // 3、返回 data return currentNode.data; } // 测试 getData 方法 console.log(linkedList.getData(0)); //--&gt; 123 console.log(linkedList.getData(1)); //--&gt; AA  实现indexOf()方法​ indexOf(data) 返回指定 data 的 index，如果没有，返回 -1。 indexOf(data) { let currentNode = this.head; let index = 0; while (currentNode) { if (currentNode.data === data) { return index; } currentNode = currentNode.next; index++; } return -1; } // 测试 indexOf 方法 console.log(linkedList.indexOf(&quot;AA&quot;)); //--&gt; 1 console.log(linkedList.indexOf(&quot;ABC&quot;)); //--&gt; -1  实现update()方法​ update(position, data) 修改指定位置节点的 data。 update(position, data) { // 涉及到 position 都要进行越界判断 // 1、position 越界判断 if (position &lt; 0 || position &gt;= this.length) return false; // 2、痛过循环遍历，找到指定 position 的节点 let currentNode = this.head; let index = 0; while (index++ &lt; position) { currentNode = currentNode.next; } // 3、修改节点 data currentNode.data = data; return currentNode; } // 测试 update 方法 linkedList.update(0, &quot;12345&quot;); console.log(linkedList.toString()); //--&gt; 12345 AA 456 BB CC linkedList.update(1, &quot;54321&quot;); console.log(linkedList.toString()); //--&gt; 12345 54321 456 BB CC  实现removeAt()方法​ removeAt(position) 删除指定位置的节点。 removeAt(position) { // 1、position 越界判断 if (position &lt; 0 || position &gt;= this.length) return null; // 2、删除指定 position 节点 let currentNode = this.head; if (position === 0) { // position = 0 的情况 this.head = this.head.next; } else { // position &gt; 0 的情况 // 通过循环遍历，找到指定 position 的节点，赋值到 currentNode let previousNode = null; let index = 0; while (index++ &lt; position) { previousNode = currentNode; currentNode = currentNode.next; } // 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。 previousNode.next = currentNode.next; } // 3、更新链表长度 -1 this.length--; return currentNode; } // 测试 removeAt 方法 linkedList.removeAt(3); console.log(linkedList.toString()); //--&gt; 12345 54321 456 CC  实现remove()方法​ remove(data) 删除指定 data 所在的节点。 remove(data) { this.removeAt(this.indexOf(data)); } // 测试 remove 方法 linkedList.remove(&quot;CC&quot;); console.log(linkedList.toString()); //--&gt; 12345 54321 456  实现isEmpty()方法​ isEmpty() 判断链表是否为空。 isEmpty() { return this.length === 0; } // 测试 isEmpty 方法 console.log(linkedList.isEmpty()); //--&gt; false  实现size()方法​ size() 获取链表的长度。 size() { return this.length; } // 测试 size 方法 console.log(linkedList.size()); //--&gt; 3  完整实现​ class LinkedList { // 初始链表长度为 0 length = 0; // 初始 head 为 null，head 指向链表的第一个节点 head = null; // 内部类（链表里的节点 Node） Node = class { data; next = null; constructor(data) { this.data = data; } }; // ------------ 链表的常见操作 ------------ // // append() 往链表尾部追加数据 append(data) { // 1、创建新节点 const newNode = new this.Node(data); // 2、追加新节点 if (this.length === 0) { // 链表长度为 0 时，即只有 head 的时候 this.head = newNode; } else { // 链表长度大于 0 时，在最后面添加新节点 let currentNode = this.head; // 当 currentNode.next 不为空时， // 循序依次找最后一个节点，即节点的 next 为 null 时 while (currentNode.next !== null) { currentNode = currentNode.next; } // 最后一个节点的 next 指向新节点 currentNode.next = newNode; } // 3、追加完新节点后，链表长度 + 1 this.length++; } // insert() 在指定位置（position）插入节点 insert(position, data) { // position 新插入节点的位置 // position = 0 表示新插入后是第一个节点 // position = 1 表示新插入后是第二个节点，以此类推 // 1、对 position 进行越界判断，不能小于 0 或大于链表长度 if (position &lt; 0 || position &gt; this.length) return false; // 2、创建新节点 const newNode = new this.Node(data); // 3、插入节点 if (position === 0) { // position = 0 的情况 // 让新节点的 next 指向 原来的第一个节点，即 head newNode.next = this.head; // head 赋值为 newNode this.head = newNode; } else { // 0 &lt; position &lt;= length 的情况 // 初始化一些变量 let currentNode = this.head; // 当前节点初始化为 head let previousNode = null; // head 的 上一节点为 null let index = 0; // head 的 index 为 0 // 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode // 直到找到要插入的位置 while (index++ &lt; position) { previousNode = currentNode; currentNode = currentNode.next; } // 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向 newNode.next = currentNode; previousNode.next = newNode; } // 更新链表长度 this.length++; return newNode; } // getData() 获取指定位置的 data getData(position) { // 1、position 越界判断 if (position &lt; 0 || position &gt;= this.length) return null; // 2、获取指定 position 节点的 data let currentNode = this.head; let index = 0; while (index++ &lt; position) { currentNode = currentNode.next; } // 3、返回 data return currentNode.data; } // indexOf() 返回指定 data 的 index，如果没有，返回 -1。 indexOf(data) { let currentNode = this.head; let index = 0; while (currentNode) { if (currentNode.data === data) { return index; } currentNode = currentNode.next; index++; } return -1; } // update() 修改指定位置节点的 data update(position, data) { // 涉及到 position 都要进行越界判断 // 1、position 越界判断 if (position &lt; 0 || position &gt;= this.length) return false; // 2、痛过循环遍历，找到指定 position 的节点 let currentNode = this.head; let index = 0; while (index++ &lt; position) { currentNode = currentNode.next; } // 3、修改节点 data currentNode.data = data; return currentNode; } // removeAt() 删除指定位置的节点 removeAt(position) { // 1、position 越界判断 if (position &lt; 0 || position &gt;= this.length) return null; // 2、删除指定 position 节点 let currentNode = this.head; if (position === 0) { // position = 0 的情况 this.head = this.head.next; } else { // position &gt; 0 的情况 // 通过循环遍历，找到指定 position 的节点，赋值到 currentNode let previousNode = null; let index = 0; while (index++ &lt; position) { previousNode = currentNode; currentNode = currentNode.next; } // 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。 previousNode.next = currentNode.next; } // 3、更新链表长度 -1 this.length--; return currentNode; } // remove() 删除指定 data 的节点 remove(data) { this.removeAt(this.indexOf(data)); } // isEmpty() 判断链表是否为空 isEmpty() { return this.length === 0; } // size() 获取链表的长度 size() { return this.length; } // toString() 链表数据以字符串形式返回 toString() { let currentNode = this.head; let result = &quot;&quot;; // 遍历所有的节点，拼接为字符串，直到节点为 null while (currentNode) { result += currentNode.data + &quot; &quot;; currentNode = currentNode.next; } return result; } }  "},{"title":"循环链表​","type":1,"pageTitle":"链表","url":"/interview/docs-data/链表#循环链表","content":"循环链表 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。  "},{"title":"双向链表​","type":1,"pageTitle":"链表","url":"/interview/docs-data/链表#双向链表","content":"双向链表 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。 既可以从头遍历到尾，也可以从尾遍历到头。链表相连的过程是双向的。实现原理是一个节点既有向前连接的引用，也有一个向后连接的引用。双向链表可以有效的解决单向链表存在的问题。双向链表缺点： 每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些。相对于单向链表，所占内存空间更大一些。但是，相对于双向链表的便利性而言，这些缺点微不足道。  双向链表的结构​  双向链表不仅有 head 指针指向第一个节点，而且有 tail 指针指向最后一个节点。每一个节点由三部分组成：item 储存数据、prev 指向前一个节点、next 指向后一个节点。双向链表的第一个节点的 prev 指向 null。双向链表的最后一个节点的 next 指向 null。 双向链表常见的操作​ append(element) 向链表尾部追加一个新元素。insert(position, element) 向链表的指定位置插入一个新元素。getElement(position) 获取指定位置的元素。indexOf(element) 返回元素在链表中的索引。如果链表中没有该元素就返回 -1。update(position, element) 修改指定位置上的元素。removeAt(position) 从链表中的删除指定位置的元素。remove(element) 从链表删除指定的元素。isEmpty() 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。size() 返回链表包含的元素个数，与数组的 length 属性类似。toString() 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。forwardString() 返回正向遍历节点字符串形式。backwordString() 返回反向遍历的节点的字符串形式。 双向链表的封装​ 创建双向链表类​ DoublyNode 类继承单向链表的 Node 类，新添加 this.prev 属性，该属性用于指向上一个节点。DoublyLinkedList 类继承 LinkedList 类，新添加 this.tail 属性，该属性指向末尾的节点。 // 双向链表的节点类（继承单向链表的节点类） class DoublyNode extends Node { constructor(element) { super(element); this.prev = null; } } // 双向链表类继承单向链表类 class DoublyLinkedList extends LinkedList { constructor() { super(); this.tail = null; } }  实现append()方法​ // append(element) 往双向链表尾部追加一个新的元素 // 重写 append() append(element) { // 1、创建双向链表节点 const newNode = new DoublyNode(element); // 2、追加元素 if (this.head === null) { this.head = newNode; this.tail = newNode; } else { // ！！跟单向链表不同，不用通过循环找到最后一个节点 // 巧妙之处 this.tail.next = newNode; newNode.prev = this.tail; this.tail = newNode; } this.length++; }  实现insert()方法​ // insert(position, data) 插入元素 // 重写 insert() insert(position, element) { // 1、position 越界判断 if (position &lt; 0 || position &gt; this.length) return false; // 2、创建新的双向链表节点 const newNode = new DoublyNode(element); // 3、判断多种插入情况 if (position === 0) { // 在第 0 个位置插入 if (this.head === null) { this.head = newNode; this.tail = newNode; } else { //== 巧妙之处：相处腾出 this.head 空间，留个 newNode 来赋值 ==// newNode.next = this.head; this.head.perv = newNode; this.head = newNode; } } else if (position === this.length) { // 在最后一个位置插入 this.tail.next = newNode; newNode.prev = this.tail; this.tail = newNode; } else { // 在 0 ~ this.length 位置中间插入 let targetIndex = 0; let currentNode = this.head; let previousNode = null; // 找到要插入位置的节点 while (targetIndex++ &lt; position) { previousNode = currentNode; currentNode = currentNode.next; } // 交换节点信息 previousNode.next = newNode; newNode.prev = previousNode; newNode.next = currentNode; currentNode.prev = newNode; } this.length++; return true; }  实现removeAt()方法​ // removeAt() 删除指定位置的节点 // 重写 removeAt() removeAt(position) { // 1、position 越界判断 if (position &lt; 0 || position &gt; this.length - 1) return null; // 2、根据不同情况删除元素 let currentNode = this.head; if (position === 0) { // 删除第一个节点的情况 /** if (this.length === 1) { // 链表内只有一个节点的情况 this.head = null; this.tail = null; } else { // 链表内有多个节点的情况 this.head = this.head.next; this.head.prev = null; } */ this.head = this.head.next || null; // null 表示后面没有节点（即当前链表中只有一个节点） this.head.prev = null; } else if (position === this.length - 1) { // 删除最后一个节点的情况 currentNode = this.tail; this.tail.prev.next = null; this.tail = this.tail.prev; } else { // 删除 0 ~ this.length - 1 里面节点的情况 let targetIndex = 0; let previousNode = null; while (targetIndex++ &lt; position) { previousNode = currentNode; currentNode = currentNode.next; } previousNode.next = currentNode.next; currentNode.next.perv = previousNode; } this.length--; return currentNode.data; }  实现update()方法​ // update(position, data) 修改指定位置的节点 // 重写 update() update(position, data) { // 1、删除 position 位置的节点 const result = this.removeAt(position); // 2、在 position 位置插入元素 this.insert(position, data); return result; }  实现forwardToString()方法​ // forwardToString() 链表数据从前往后以字符串形式返回 forwardToString() { let currentNode = this.head; let result = ''; // 遍历所有的节点，拼接为字符串，直到节点为 null while (currentNode) { result += currentNode.data + '--'; currentNode = currentNode.next; } return result; }  实现backwardString()方法​ // backwardString() 链表数据从后往前以字符串形式返回 backwardString() { let currentNode = this.tail; let result = ''; // 遍历所有的节点，拼接为字符串，直到节点为 null while (currentNode) { result += currentNode.data + '--'; currentNode = currentNode.prev; } return result; }  其他方法的实现​ 双向链表的其他方法通过继承单向链表来实现。 完整实现​ class DoublyLinkedList extends LinkedList { constructor() { super(); this.tail = null; } // ------------ 链表的常见操作 ------------ // // append(element) 往双向链表尾部追加一个新的元素 // 重写 append() append(element) { // 1、创建双向链表节点 const newNode = new DoublyNode(element); // 2、追加元素 if (this.head === null) { this.head = newNode; this.tail = newNode; } else { // ！！跟单向链表不同，不用通过循环找到最后一个节点 // 巧妙之处 this.tail.next = newNode; newNode.prev = this.tail; this.tail = newNode; } this.length++; } // insert(position, data) 插入元素 // 重写 insert() insert(position, element) { // 1、position 越界判断 if (position &lt; 0 || position &gt; this.length) return false; // 2、创建新的双向链表节点 const newNode = new DoublyNode(element); // 3、判断多种插入情况 if (position === 0) { // 在第 0 个位置插入 if (this.head === null) { this.head = newNode; this.tail = newNode; } else { //== 巧妙之处：相处腾出 this.head 空间，留个 newNode 来赋值 ==// newNode.next = this.head; this.head.perv = newNode; this.head = newNode; } } else if (position === this.length) { // 在最后一个位置插入 this.tail.next = newNode; newNode.prev = this.tail; this.tail = newNode; } else { // 在 0 ~ this.length 位置中间插入 let targetIndex = 0; let currentNode = this.head; let previousNode = null; // 找到要插入位置的节点 while (targetIndex++ &lt; position) { previousNode = currentNode; currentNode = currentNode.next; } // 交换节点信息 previousNode.next = newNode; newNode.prev = previousNode; newNode.next = currentNode; currentNode.prev = newNode; } this.length++; return true; } // getData() 继承单向链表 getData(position) { return super.getData(position); } // indexOf() 继承单向链表 indexOf(data) { return super.indexOf(data); } // removeAt() 删除指定位置的节点 // 重写 removeAt() removeAt(position) { // 1、position 越界判断 if (position &lt; 0 || position &gt; this.length - 1) return null; // 2、根据不同情况删除元素 let currentNode = this.head; if (position === 0) { // 删除第一个节点的情况 if (this.length === 1) { // 链表内只有一个节点的情况 this.head = null; this.tail = null; } else { // 链表内有多个节点的情况 this.head = this.head.next; this.head.prev = null; } } else if (position === this.length - 1) { // 删除最后一个节点的情况 currentNode = this.tail; this.tail.prev.next = null; this.tail = this.tail.prev; } else { // 删除 0 ~ this.length - 1 里面节点的情况 let targetIndex = 0; let previousNode = null; while (targetIndex++ &lt; position) { previousNode = currentNode; currentNode = currentNode.next; } previousNode.next = currentNode.next; currentNode.next.perv = previousNode; } this.length--; return currentNode.data; } // update(position, data) 修改指定位置的节点 // 重写 update() update(position, data) { // 1、删除 position 位置的节点 const result = this.removeAt(position); // 2、在 position 位置插入元素 this.insert(position, data); return result; } // remove(data) 删除指定 data 所在的节点（继承单向链表） remove(data) { return super.remove(data); } // isEmpty() 判断链表是否为空 isEmpty() { return super.isEmpty(); } // size() 获取链表的长度 size() { return super.size(); } // forwardToString() 链表数据从前往后以字符串形式返回 forwardToString() { let currentNode = this.head; let result = &quot;&quot;; // 遍历所有的节点，拼接为字符串，直到节点为 null while (currentNode) { result += currentNode.data + &quot;--&quot;; currentNode = currentNode.next; } return result; } // backwardString() 链表数据从后往前以字符串形式返回 backwardString() { let currentNode = this.tail; let result = &quot;&quot;; // 遍历所有的节点，拼接为字符串，直到节点为 null while (currentNode) { result += currentNode.data + &quot;--&quot;; currentNode = currentNode.prev; } return result; } } // 测试 const doublyLinkedList = new DoublyLinkedList(); // append() 测试 doublyLinkedList.append(&quot;ZZ&quot;); doublyLinkedList.append(&quot;XX&quot;); doublyLinkedList.append(&quot;CC&quot;); console.log(doublyLinkedList); // insert() 测试 doublyLinkedList.insert(0, &quot;00&quot;); doublyLinkedList.insert(2, &quot;22&quot;); console.log(doublyLinkedList); // getData() 测试 console.log(doublyLinkedList.getData(1)); //--&gt; ZZ // indexOf() 测试 console.log(doublyLinkedList.indexOf(&quot;XX&quot;)); //--&gt; 3 console.log(doublyLinkedList); // removeAt() 测试 doublyLinkedList.removeAt(0); doublyLinkedList.removeAt(1); console.log(doublyLinkedList); // update() 测试 doublyLinkedList.update(0, &quot;111111&quot;); console.log(doublyLinkedList); // remove() 测试 console.log(doublyLinkedList.remove(&quot;111111&quot;)); console.log(doublyLinkedList.remove(&quot;22222&quot;)); console.log(doublyLinkedList); // forwardToString() 测试 console.log(doublyLinkedList.forwardToString()); // backwardString() 测试 console.log(doublyLinkedList.backwardString());  "},{"title":"双向循环链表​","type":1,"pageTitle":"链表","url":"/interview/docs-data/链表#双向循环链表","content":"双向循环链表 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。  "},{"title":"链表的应用场景​","type":1,"pageTitle":"链表","url":"/interview/docs-data/链表#链表的应用场景","content":"如果需要支持随机访问的话，链表没办法做到。如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适。如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。 "},{"title":"单向链表和双向链表的对比​","type":1,"pageTitle":"链表","url":"/interview/docs-data/链表#单向链表和双向链表的对比","content":"单向链表 只能从头遍历到尾或者从尾遍历到头（一般从头到尾）。链表相连的过程是单向的，实现原理是上一个节点中有指向下一个节点的引用。单向链表有一个比较明显的缺点：可以轻松到达下一个节点，但回到前一个节点很难，在实际开发中, 经常会遇到需要回到上一个节点的情况。 双向链表 既可以从头遍历到尾，也可以从尾遍历到头。链表相连的过程是双向的。实现原理是一个节点既有向前连接的引用，也有一个向后连接的引用。双向链表可以有效的解决单向链表存在的问题。双向链表缺点： 每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些。相对于单向链表，所占内存空间更大一些。但是，相对于双向链表的便利性而言，这些缺点微不足道。 "}]